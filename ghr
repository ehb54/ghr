#!/usr/bin/env perl
use strict;
use warnings;
use Cwd 'abs_path';
use JSON 'decode_json', 'encode_json';
use FindBin qw($Bin);
use lib $Bin;
use GHRUtils;
use GHRCmds;

# Global path for session caching
# File::Slurp, Term::ReadLine::Gnu or similar would be needed for a richer experience,
# but for basic CLI in emacs shell, standard IO is fine.

# --- Global State ---
our $current_pr = undef;
our $current_file_index = undef; # 1-based index from 'lf'
our $current_file_name = undef; # Actual file path
our @pr_files = (); # Array of file names for the current PR
our %comments = (
    'global' => [], # Array of global comments: {text => ..., status => 'local'|'pushed'}
    'files' => {}, # Hash: 'path/to/file.txt' => [ {line => ..., pos => ..., text => ..., status => 'local'|'pushed'}, ... ]
    'review_state' => undef # 'approve' | 'request_changes'
);
our %files_data;
our @grep_set = ();      # Array of 1-based file indices that match the last 'g' regexp
our $current_grep_index = undef; # 1-based index into @grep_set
our @command_history = (); # Array to store executed commands
our $history_max_size = 100; # Maximum number of commands to store

# --- Command Dispatch Table ---
# Maps user input to the corresponding subroutine
my %COMMANDS = (
    'q'       => \&cmd_quit,
    '?'       => \&cmd_help,
    'h'       => \&cmd_history,
    'lpr'     => \&cmd_list_prs,
    'lc'      => \&cmd_load_comments,
    'lgc'     => \&cmd_load_general_comments,
    'pr'      => \&cmd_select_pr,
    'lf'      => \&cmd_list_files,
    'fn'      => \&cmd_select_file,
    'f'       => \&cmd_select_file_name_regexp,
    '+'       => \&cmd_select_file,
    '-'       => \&cmd_select_file,
    'dd'      => \&cmd_show_diffs,
    'g'       => \&cmd_grep_diffs,
    'gl'      => \&cmd_grep_local,
    'g+'      => \&cmd_grep_diffs_next,
    'g-'      => \&cmd_grep_diffs_prev,
    'ddiw'    => \&cmd_show_diffs_ignore_whitespace,
    'do'      => \&cmd_show_original,
    'dn'      => \&cmd_show_new,
    'ca'      => \&cmd_add_comment,
    'cd'      => \&cmd_delete_comment,
    'cp'      => \&cmd_push_comments,
    'rs'      => \&cmd_review_summary,
    'accept'  => \&cmd_accept_review,
    'reject'  => \&cmd_reject_review,
    'ajim'    => \&cmd_gemini_chat,
    'agtp'    => \&cmd_openai_chat,
);

# --- GH CLI Check ---
sub check_gh_auth {
    # Check if 'gh' is installed and authenticated by running a simple command
    my $output = `gh auth status 2>&1`;
    if ($? != 0 || $output =~ /not logged into any GitHub hosts/) {
        die "Error: 'gh' command failed or you are not logged in.\nPlease run 'gh auth login'.\n";
    }
    print "GitHub CLI is authenticated.\n";
}
check_gh_auth();

cmd_load_session();

# --- Main Logic ---
sub get_prompt {
    my $prompt = '-'x120 . "\nghr";

    if (defined $current_pr) {
        $prompt .= " \#$current_pr";

        # --- Add File Index and Total Count ---
        if (defined $current_file_name) {
            # 1. Get total count using the PR file list if available
            my $total_files = scalar(@pr_files) || scalar(keys %files_data) || 0;

            # 2. Get current index (guaranteed to be defined if $current_file_name is defined)
            my $current_index = $current_file_index // 0;

            # Format the prompt segment: [1/100] filename
            my $pct = $total_files ? 100 * ($current_index / $total_files) : 0;
            $prompt .= sprintf(" [%d/%d | %.1f%%] %s", $current_index, $total_files, $pct, $current_file_name);
        }
    }

    $prompt .= " > ";
    return $prompt;
}

sub main {
    load_history();
    while (1) {
        # 1. Print the dynamic prompt
        print get_prompt();

        # 2. Read line (Control-D/EOF will result in undef)
        my $raw_input = <STDIN>;
        last unless defined $raw_input; # Exit on EOF (Ctrl-D)

        chomp $raw_input;
        my $user_input = $raw_input;
        $user_input =~ s/^\s+|\s+$//g; # Trim whitespace

        next unless length $user_input; # Skip empty lines

        # 3. History Preprocessing
        # This function resolves !! or !N into the actual command string.
        # It returns undef for history-only commands like 'h' or '!!:p'.
        my $executed_command = process_history_input($user_input);

        # If $executed_command is undef, it means the input was 'h', '!!:p', or an error.
        # We check for 'h' explicitly here because 'process_history_input' only handles '!' expansions.
        if (!defined $executed_command) {
            # Handle 'h' if it wasn't caught by the history processor
            if ($user_input =~ /^\s*h(istory)?\s*$/i) {
                # This ensures 'h' still works if it's not a history expansion.
                cmd_history();
            }
            next; # Skip command dispatch for history print/error
        }

        # 4. Command Dispatch and Execution
        # Use the resolved command for dispatch
        my @parts = split /\s+/, $executed_command, 2;
        my $cmd = lc $parts[0];
        my $args = $parts[1] // '';

        # --- FIX: If command is '+' or '-', set $args to the command itself ---
        # This ensures the '+' command passes '+' as the argument to cmd_select_file
        if (($cmd eq '+' || $cmd eq '-') && $args eq '') {
            $args = $cmd;
        }

        if (my $sub = $COMMANDS{$cmd}) {
            eval {
                $sub->($args);
            };
            if ($@) {
                print "Command Error: $@\n";
            }
        } else {
            print "Unknown command: '$cmd'. Type 'h' for help.\n";
        }

        # 5. Store the executed command in history
        # Store only if it wasn't a history lookup/print and was successfully dispatched (or attempted).
        # We store the fully resolved command string ($executed_command).
        # Note: We skip storing history lookups (like '!!', '!5', 'h') to keep the history clean.
        if ($user_input !~ /^\s*(h(istory)?|!\d*|!!)(:\S*)?\s*$/i) {
            push @command_history, $executed_command;

            # Keep array size bounded
            if (scalar(@command_history) > $history_max_size) {
                shift @command_history;
            }
        }
    }
    save_history();
    print "\nExiting.\n";
}

main(); # Start the program

# --- Command Implementations ---

sub cmd_quit { GHRCmds::cmd_quit(@_); }

sub cmd_help { GHRCmds::cmd_help(@_); }

sub cmd_list_prs { GHRCmds::cmd_list_prs(@_); }

sub cmd_select_pr { GHRCmds::cmd_select_pr(@_); }

sub cmd_list_files { GHRCmds::cmd_list_files(@_); }


sub cmd_select_file { GHRCmds::cmd_select_file(@_); }

sub get_file_diff_content { return GHRUtils::get_file_diff_content(@_); }

sub cmd_show_diffs { GHRCmds::cmd_show_diffs(@_); }

sub cmd_show_original { GHRCmds::cmd_show_original(@_); }

sub cmd_show_new { GHRCmds::cmd_show_new(@_); }

sub cmd_add_comment { GHRCmds::cmd_add_comment(@_); }

# --- Utility to map position to line number (CORRECTED) ---
# This is crucial for building the 'gh pr review --comments' JSON later.
sub _map_pos_to_line { return GHRUtils::map_pos_to_line(@_); }

sub cmd_delete_comment { GHRCmds::cmd_delete_comment(@_); }

sub cmd_review_summary { GHRCmds::cmd_review_summary(@_); }

sub build_comments_json { return GHRUtils::build_comments_json(@_); }
sub _mark_local_comments_as_pushed { return GHRUtils::mark_local_comments_as_pushed(@_); }
sub _prepare_unified_body_file { return GHRUtils::prepare_unified_body_file(@_); }

sub cmd_push_comments { GHRCmds::cmd_push_comments(@_); }

sub cmd_accept_review { GHRCmds::cmd_accept_review(@_); }

sub cmd_reject_review { GHRCmds::cmd_reject_review(@_); }

sub _submit_review { GHRCmds::_submit_review(@_); }

sub cmd_load_comments { GHRCmds::cmd_load_comments(@_); }

sub cmd_load_general_comments { GHRCmds::cmd_load_general_comments(@_); }

sub cmd_show_diffs_ignore_whitespace { GHRCmds::cmd_show_diffs_ignore_whitespace(@_); }

sub cmd_load_session { GHRCmds::cmd_load_session(@_); }

sub get_session_file_path { return GHRUtils::get_session_file_path(@_); }

