#!/usr/bin/env perl

use strict;
use warnings;
use FindBin '$Bin';
use lib $Bin;

# Declare shared globals here (actual initialization lives in ghr_global.pl)
our (
    $current_pr,
    $current_file_index,
    $current_file_name,
    @pr_files,
    %comments,
    %files_data,
    @grep_set,
    $current_grep_index,
    @command_history,
    $history_max_size,
    %COMMANDS,
);

# Minimal loader: require globals, utils, commands, and CLI (split files)
my $globals_file = "$Bin/ghr_global.pl";
do $globals_file or die "Failed to load $globals_file: $! $@\n";

my $utils_file = "$Bin/ghr_utils.pl";
do $utils_file or die "Failed to load $utils_file: $! $@\n";

my $cmds_file = "$Bin/ghr_cmds.pl";
do $cmds_file or die "Failed to load $cmds_file: $! $@\n";

my $cli_file = "$Bin/ghr_cli.pl";
do $cli_file or die "Failed to load $cli_file: $! $@\n";

1;
# Utility: Builds a single file containing both the global review body and 
#          the positional comments in the format required by 'gh pr review'.
# Returns: The path to the temporary body file, or undef if no comments/status to push.
sub _prepare_unified_body_file {
    my ($review_type) = @_; # 'comment', 'approve', or 'request_changes'
    
    my @global_local_comments = grep { $_->{status} eq 'local' } @{$comments{global}};
    my $has_local_positional = get_unpushed_comment_count() > scalar(@global_local_comments);
    
    # If no local comments and no explicit approval/rejection, nothing to push
    unless (scalar(@global_local_comments) > 0 || $has_local_positional || $review_type ne 'comment') {
        return undef;
    }
    
    # --- 1. Build the Review Body (Global Comments) ---
    my $review_body = "";
    if (@global_local_comments) {
        $review_body = join("\n---\n", map { "GLOBAL COMMENT:\n" . $_->{text} } @global_local_comments);
    } elsif ($review_type ne 'comment') {
        # If we are accepting/rejecting, provide a default minimal body if no global comments exist
        $review_body = "Review submitted via interactive CLI.";
    }

    # --- 2. Build the Positional Comments Section ---
    my $comments_section = "";
    if ($has_local_positional) {
        $comments_section .= "\n\n## Comments\n";
        
        # Iterate through all files that have local comments
        foreach my $file_name (keys %{$comments{files}}) {
            my @file_comments = @{$comments{files}{$file_name}};
            
            # Filter for only local, unpushed comments
            foreach my $c (grep { $_->{status} eq 'local' } @file_comments) {
                # gh pr review positional comments require line or position. We use line (safer).
                # The format uses YAML list syntax.
                $comments_section .= sprintf("- path: %s\n", $c->{file});
                $comments_section .= sprintf("  line: %s\n", $c->{line}); 
                $comments_section .= sprintf("  body: %s\n", $c->{text});
            }
        }
    }
    
    # --- 3. Create the Temporary File ---
    my ($fh, $temp_file) = tempfile("ghr_unified_XXXXXX", DIR => "/tmp", UNLINK => 1);
    print $fh $review_body;
    print $fh $comments_section;
    close $fh;
    
    return $temp_file;
}

sub cmd_push_comments {
    my $unpushed_count = get_unpushed_comment_count();

    if ($unpushed_count == 0) {
        print "No new local comments to push for PR #$current_pr.\n";
        return;
    }
    
    print "\nYou have **$unpushed_count** local comments (global and positional).\n";
    print "Are you sure you want to push these comments to GitHub now? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    return unless $confirm =~ /^[yY]/;
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file('comment'); # Pass 'comment' review type
    
    unless (defined $temp_file) {
        print "Error: Failed to create unified comment body file.\n";
        return;
    }
    
    # --- 2. Execute Command (gh pr review) ---
    # The combination of '--comment' and '--body-file' is the correct syntax
    # for a comment-only submission without changing the review status.
    my @cmd_parts = ("gh", "pr", "review", $current_pr, "--comment", "--body-file", $temp_file);

    print "\nPushing comments via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully pushed all $unpushed_count comment(s) to PR #$current_pr.\n";
        _mark_local_comments_as_pushed();
    } else {
        print "\n‚ùå Error pushing comments. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

sub cmd_accept_review {
    return unless defined $current_pr;
    $comments{review_state} = 'APPROVE';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting an **APPROVAL** of PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('approve');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Approval submission cancelled.\n";
    }
}

sub cmd_reject_review {
    return unless defined $current_pr;
    $comments{review_state} = 'REQUEST_CHANGES';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting a **REQUEST FOR CHANGES** on PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('request_changes');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Rejection submission cancelled.\n";
    }
}

sub _submit_review {
    my ($review_type) = @_; # 'approve' or 'request_changes'
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file($review_type);

    # If no comments and no body file, we still submit the state, but gh may fail without a body file.
    # To be safe, we always generate a body file, even if minimal.
    unless (defined $temp_file) {
        # Fallback: Create a minimal body file if _prepare_unified_body_file returned undef
        my $default_body = $review_type eq 'approve' ? "Approved." : "Changes requested.";
        my ($fh, $filename) = tempfile("ghr_minimal_XXXXXX", DIR => "/tmp", UNLINK => 1);
        print $fh $default_body;
        close $fh;
        $temp_file = $filename;
    }

    # --- 2. Execute Command ---
    my $flag = ($review_type eq 'approve') ? '--approve' : '--request-changes';
    
    my @cmd_parts = ("gh", "pr", "review", $current_pr, $flag, "--body-file", $temp_file);
    
    print "\nSubmitting review via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully submitted review as " . uc($review_type) . " for PR #$current_pr.\n";
        # Mark all local comments as pushed
        _mark_local_comments_as_pushed();
        $comments{review_state} = uc($review_type);
    } else {
        # Revert state on failure
        $comments{review_state} = 'PENDING';
        print "\n‚ùå Error submitting review. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

sub cmd_load_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching submitted review comments for PR #$current_pr...\n";

    # --- 1. Get the repository path (owner/repo) using GH context variables ---
    # This path resolves the current repository context using {owner} and {repo}.
    my $repo_path_cmd = "gh api repos/{owner}/{repo} --jq '.full_name' 2>/dev/null";

    # For debugging: print "cmd: $repo_path_cmd\n"; 

    my $repo_path = `$repo_path_cmd`;
    chomp $repo_path;

    # Check the result. It should now return "ehb54/ultrascan3"
    if ($? != 0 || !$repo_path || $repo_path !~ /\//) {
        print "Error: Failed to determine repository path (owner/repo) using 'gh api'. Check your current directory and authentication.\n";
        return;
    }
    
    # Clean up any potential surrounding quotes from the jq output
    $repo_path =~ s/^"|"$//g;
    
    # --- 2. API Call to Fetch Positional Comments ---
    # Use the retrieved $repo_path to call the GitHub REST API.
    my $api_cmd = "gh api repos/$repo_path/pulls/$current_pr/comments --jq '
        .[] | {
            user: .user.login,
            body: .body,
            path: .path,
            line: .line,
            position: .position,
            created_at: .created_at
        }'";

    my $json_output = `$api_cmd`;
    
    if ($? != 0) {
        print "Error: Failed to fetch comments via gh api. Check permissions and 'gh auth status'.\n";
        return;
    }

    # --- 3. Parse and Display (Logic remains the same) ---
    my @comments_data = ();
    
    # gh api + jq returns a stream of JSON objects; split by newline and parse each
    foreach my $json_line (split /\n/, $json_output) {
        next unless $json_line =~ /^{/;
        eval {
            push @comments_data, decode_json($json_line);
        };
        if ($@) {
            print "Warning: Failed to parse comment JSON: $@\n";
        }
    }

    if (!@comments_data) {
        print "No submitted positional review comments found for PR #$current_pr.\n";
        return;
    }
    
    # Sort by file path and then line number for clean display
    @comments_data = sort { 
        $a->{path} cmp $b->{path} || $a->{line} <=> $b->{line} 
    } @comments_data;

    print "\n### üí¨ Submitted Comments by Other Reviewers ###\n";
    print "------------------------------------------------------\n";

    my $current_path = "";
    foreach my $c (@comments_data) {
        if ($c->{path} ne $current_path) {
            $current_path = $c->{path};
            print "\nFile: **$current_path**\n";
        }

        my $date_str = substr($c->{created_at}, 0, 10);
        
        print sprintf(" %-15s (Line: %-4s | Pos: %-4s) [%s]\n", 
            $c->{user}, $c->{line}, $c->{position}, $date_str
        );
        # Use simple indentation for the body
        my $body_preview = (split /\n/, $c->{body})[0];
        print "    > $body_preview...\n";
    }
    print "------------------------------------------------------\n";
}

sub cmd_load_general_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching general discussion comments for PR #$current_pr...\n";

    # Use gh pr view --json comments to get the list of PR discussion comments
    my $cmd = "gh pr view $current_pr --json comments 2>/dev/null";

    my $json_output = `$cmd`;
    
    if ($? != 0) {
        print "Error: Failed to execute 'gh pr view --json comments'.\n";
        return;
    }

    my $data;
    eval {
        $data = decode_json($json_output);
    };

    if ($@ || !defined $data->{comments} || !ref $data->{comments}) {
        print "Error: Failed to parse general comments JSON.\n";
        return;
    }

    my @comments = @{$data->{comments}};

    if (!@comments) {
        print "No general discussion comments found for PR #$current_pr.\n";
        return;
    }
    
    print "\n### üí¨ General PR Discussion Comments (" . scalar(@comments) . ") ###\n";
    print "------------------------------------------------------\n";

    # Display comments in reverse chronological order (newest first)
    @comments = sort { $b->{createdAt} cmp $a->{createdAt} } @comments;

    for my $c (@comments) {
        my $user = $c->{author}->{login} // 'Unknown User';
        my $date_str = substr($c->{createdAt}, 0, 10);
        my $body = $c->{body} // 'No body content.';
        
        # Display the header and a short preview
        print sprintf("\n[%s] Comment by **%s** on %s\n", 
            $c->{id} || 'N/A', $user, $date_str
        );
        
        # Use a blockquote for the body content
        my @body_lines = split /\n/, $body;
        my $preview_lines = 0;
        
        for my $line (@body_lines) {
            # Skip empty lines that might start the body
            next if $line =~ /^\s*$/ && $preview_lines == 0; 
            
            # Print up to 64 lines of preview
            print "    > $line\n";
            $preview_lines++;
            last if $preview_lines >= 64;
        }

        # Indicate if the comment was truncated
        print "    > ... (truncated) ...\n" if scalar(@body_lines) > $preview_lines;
    }
    print "------------------------------------------------------\n";
}

sub cmd_show_diffs_ignore_whitespace {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }
    if (!defined $current_file_name) {
        print "Error: No file selected. Use 'sf <file#>' or '+' first.\n";
        return;
    }

    # --- 1. Ensure the PR's head commit is local (Required to avoid 'bad object') ---
    print "Ensuring PR #$current_pr history is available locally...\n";
    
    # Use git fetch with the PR refspec to pull down the required commits without checking out the branch.
    # The refspec format is 'pull/<PR_NUM>/head'.
    my @fetch_cmd = ("git", "fetch", "origin", "pull/$current_pr/head:refs/pr_temp/$current_pr");
    
    print "Executing: @fetch_cmd\n";
    # We use system for git commands that modify the local repo state (like fetch)
    system(@fetch_cmd); 
    
    if ($? != 0) {
        print "\nError: Failed to fetch PR #$current_pr head commits. Cannot proceed with diff.\n";
        return;
    }
    print "Fetch complete.\n";

    # --- 2. Fetch the necessary commit SHAs using gh pr view ---
    print "Fetching base and head commit SHAs...\n";
    
    # We need baseRefOid (the base branch's commit) and headRefOid (the PR branch's commit)
    my $sha_cmd = "gh pr view $current_pr --json baseRefOid,headRefOid 2>/dev/null";
    my $json_output = `$sha_cmd`;

    # ... (Error handling and JSON parsing remains the same) ...
    my $data;
    eval { $data = decode_json($json_output); };
    if ($@ || !defined $data->{baseRefOid} || !defined $data->{headRefOid}) {
        print "Error: Failed to parse commit SHAs from gh CLI output.\n";
        return;
    }
    
    my $base_sha = $data->{baseRefOid};
    my $head_sha = $data->{headRefOid};
    
    print "Diff (ignoring whitespace) for file: **$current_file_name**\n";

    # --- 3. Execute the raw 'git diff' command ---
    my @diff_cmd_parts = (
        "git",
        "diff",
        "--ignore-all-space", # The desired flag
        "$base_sha",          # Base commit SHA
        "$head_sha",          # Head commit SHA
        "--",                 # Separator
        $current_file_name    # File path
    );
    
    system(@diff_cmd_parts);
    
    # --- 4. Cleanup (Optional, but recommended) ---
    # Delete the temporary fetched reference after the diff is done.
    system("git", "update-ref", "-d", "refs/pr_temp/$current_pr");
}

sub cmd_load_session {
    my $session_file_path = get_session_file_path();

    # Check if the session file exists
    unless (-e $session_file_path) {
        print "No previous session found.\n";
        return;
    }

    print "Attempting to load previous session from $session_file_path...\n";

    my $data;
    eval {
        # Read the JSON file
        local $/; # Enable slurp mode
        open(my $fh, '<', $session_file_path) or die "Could not open file: $!";
        my $json_text = <$fh>;
        close $fh;

        # Decode the JSON
        $data = decode_json($json_text);
    };

    if ($@) {
        print "Warning: Failed to load or parse session file: $@\n";
        return;
    }

    # --- Restore State ---
    my $pr_num = $data->{pr_num} // undef;
    my $file_name = $data->{file_name} // undef;

    if (defined $pr_num) {
        print "Restoring PR #$pr_num.\n";

        # We must call cmd_select_pr to populate %files_data and $current_pr
        cmd_select_pr($pr_num, -1); # -1 prevents selecting a file

        if (defined $file_name && defined $current_pr) {
            # Find the index of the saved file name within the newly loaded file list
            my @pr_files = sort keys %files_data;
            my $found_index = 0;

            for my $i (0 .. $#pr_files) {
                if ($pr_files[$i] eq $file_name) {
                    $found_index = $i + 1; # Convert 0-based to 1-based index
                    last;
                }
            }

            if ($found_index > 0) {
                print "Restoring file: $file_name (index $found_index).\n";
                # Call cmd_select_file to select the file and show the diff
                # Note: We must call cmd_select_file with the index, not the file name
                cmd_select_file($found_index, 1);
            } else {
                print "Warning: File '$file_name' not found in PR \#{$pr_num}'s file list.\n";
            }
        }
    }
}

sub get_session_file_path {
    my $home = $ENV{HOME} || $ENV{USERPROFILE} || die "Could not determine home directory (neither HOME nor USERPROFILE set)";
    return "$home/.ghr_session.json";
}

#!/usr/bin/perl
#
# This script defines and runs the cmd_gemini_chat function, which initiates
# a continuous, interactive, and stateful (conversational) session with the
# Gemini API using the GeminiConverse module.
#
# PREREQUISITES:
# 1. The GEMINI_API_KEY environment variable must be set.
# 2. The GeminiConverse.pm module must be in the same directory or in PERL's @INC.
# 3. Ensure your terminal is set to UTF-8 (though we are bypassing most of that
#    complexity by focusing on the logic here).

use FindBin '$Bin';
use lib $Bin;
use GeminiConverse qw(new);

# ----------------------------------------------------------------------
# cmd_gemini_chat
#
# Launches an interactive chat session in the terminal.
# Arguments:
#   - $model: (Optional) The Gemini model to use. Defaults to $DEFAULT_MODEL.
#   - $system_prompt: (Optional) The initial persona/instruction. Defaults to $DEFAULT_SYSTEM.
# ----------------------------------------------------------------------
sub cmd_gemini_chat {
    my ($arg) = @_;

    # Use defaults if arguments are not provided
    my $model         = 'gemini-2.5-flash';
    my $system_prompt =
        'you are a Veteran C++ Architect (ISO/IEC 14882 expert). Your sole function is to review provided code diffs. Your review must be concise, direct, and actionable, adhering strictly to C++17 standards and best practices (RAII, smart pointers, constexpr). Focus on:
1. **Memory Safety:** Immediately flag any raw pointer use, manual memory management, or potential leaks.
2. **Performance:** Identify inefficient loops, excessive copying, or unnecessary dynamic allocation.
3. **Correctness:** Check for threading issues, race conditions, and undefined behavior.
4. **Design:** Ensure proper use of polymorphism, templates, and adherence to SOLID principles where applicable.
Suppress any introductory or conversational preambles. Get straight to the review points.';

    # 1. Pre-Check and Initialization
    unless ($ENV{GEMINI_API_KEY}) {
        print STDERR "FATAL: GEMINI_API_KEY environment variable not set.\n";
        return;
    }

    print "--- Starting Interactive Gemini Chat ---\n";
    print "Model: $model\n";
    print "Persona: '" . substr( $system_prompt, 0, 80 ) . "...'\n";
    print "Type /q or /e to end the conversation.\n\n";

    # Create the conversational session object (this holds the memory)
    my $chat = GeminiConverse->new(
        model  => $model,
        system => $system_prompt,
        );

    # 2. Main Chat Loop
    while (1) {
        # Prompt for user input
        print "gemini > ";

        # Read the line (strips the newline)
        my $user_input = <STDIN>;
        last unless defined $user_input; # Handle EOF (Ctrl+D)
        chomp $user_input;
        $user_input =~ s/^\s+|\s+$//g; # Trim whitespace

        # Check for exit commands
        if ($user_input =~ /^\/(q|e|\.)$/i) {
            print "\nSession closed. Goodbye!\n";
            last;
        }

        # Skip if input is empty after trimming
        next unless length $user_input;

        # 3. Get Reply and Handle Errors
        my $reply;
        eval {
            $reply = $chat->reply($user_input);
        };

        if ($@) {
            # Catch API or network errors
            print STDERR "\nü§ñ ERROR: An issue occurred during the API call.\n";
            print STDERR "Details: $@\n\n";
        } elsif (defined $reply) {
            # Print the model's response
            print "ü§ñ jim: $reply\n\n";
        } else {
            # Fallback for unexpected empty reply
            print "ü§ñ jim: (I received no response from the model.)\n\n";
        }
    }
}

sub cmd_grep_diffs {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: g <regexp>\n";
        return;
    }

    # Reset the grep set and index
    @grep_set = ();
    $current_grep_index = undef;

    # Get the sorted list of file names and search
    my @pr_files = sort keys %files_data;

    print "Searching diffs for **'$regexp'** in " . scalar(@pr_files) . " files...\n";

    for my $i (0 .. $#pr_files) {
        my $file_name = $pr_files[$i];
        my $file_index = $i + 1; # 1-based index

        # Retrieve the raw diff content for the file
        my ($diff, $err) = get_file_diff_content($file_name);

        # Skip if error
        next if $err;

        # Search only added (+) or removed (-) lines, ignoring context lines (space)
        my $match_found = 0;
        foreach my $line (split /\n/, $diff) {
            # Use '^[+-]' to target only changed lines in the diff
            if ($line =~ /^[+-]/ && $line =~ /$regexp/i) {
                $match_found = 1;
                last;
            }
        }

        if ($match_found) {
            # Store the **1-based file index**
            push @grep_set, $file_index;
            print sprintf("  [ %2d ]: %s\n", $file_index, $file_name);
        }
    }

    my $match_count = scalar(@grep_set);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp'.\n";
        # Select the first matching file and set the grep index
        $current_grep_index = 1;
        my $first_file_index = $grep_set[0];
        print "Selecting first matching file (Index $first_file_index).\n";

        # Select file and show diffs automatically
        cmd_select_file($first_file_index, 0);
    } else {
        print "No files found matching '$regexp' in diffs.\n";
    }
}

# --- Utility to navigate the grep set (used by g+ and g-) ---
sub _navigate_grep_set {
    my ($direction) = @_; # +1 for next, -1 for previous

    if (!@grep_set) {
        print "No previous 'g' command set. Use 'g <regexp>' first.\n";
        return;
    }

    # Ensure index is defined (should be 1 after 'g')
    if (!defined $current_grep_index) {
        $current_grep_index = 1;
    }

    my $new_grep_index = $current_grep_index + $direction;
    my $max_grep_index = scalar(@grep_set);

    if ($new_grep_index < 1) {
        print "Beginning of grep set reached (at file 1).\n";
        return;
    } elsif ($new_grep_index > $max_grep_index) {
        print "End of grep set reached (at file $max_grep_index).\n";
        return;
    }

    # Update state
    $current_grep_index = $new_grep_index;

    # Get the actual 1-based file index from the grep set array
    my $file_index_to_select = $grep_set[$current_grep_index - 1];

    print "Navigating to file **$current_grep_index/$max_grep_index** in grep set (File index $file_index_to_select).\n";

    # Select file and show diffs
    cmd_select_file($file_index_to_select, 0);
}

### `cmd_grep_diffs_next` (`g+`)
sub cmd_grep_diffs_next {
    _navigate_grep_set(1);
}

### `cmd_grep_diffs_prev` (`g-`)
sub cmd_grep_diffs_prev {
    _navigate_grep_set(-1);
}

sub cmd_grep_local {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: gl <regexp>\n";
        return;
    }

    # Reset the global grep set and index for navigation
    @grep_set = ();
    $current_grep_index = undef;

    # Assuming @pr_files contains the full list of file paths for the current PR
    my @pr_files_sorted = sort @pr_files;

    print "Branch: " . get_current_branch() . "\n";
    print "üîç Searching **local files** for pattern: **'$regexp'** in " . scalar(@pr_files_sorted) . " files...\n";

    # Iterate through the files tracked in the PR
    for my $i (0 .. $#pr_files_sorted) {
        my $file_name = $pr_files_sorted[$i];
        my $file_index = $i + 1; # 1-based index

        # Pure Perl File Reading with open handle
        unless (-f $file_name) {
            print STDERR "Skipping '$file_name': File not found locally.\n";
            next;
        }

        open my $fh, '<', $file_name or do {
            warn "Could not open '$file_name': $!\n";
            next;
        };

        my $match_found = 0;
        my $line_num = 0;

        # Search line by line
        while (my $line = <$fh>) {
            $line_num++;

            # Perform the case-sensitive regex match
            if ($line =~ /$regexp/i) {
                if (!$match_found) {
                    # Only print header once per file
                    print "\n-- **$file_name** (Index $file_index) --\n";
                }
                $match_found = 1;

                # Print the line number and the matching line content
                print sprintf("  %4d: %s", $line_num, $line);
            }
        }
        close $fh;

        if ($match_found) {
            # Store the **1-based file index** for g+/g- navigation
            push @grep_set, $file_index;
        }
    }

    my $match_count = scalar(@grep_set);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp'.\n";

        # ü§ù Integrate with g+ / g- navigation
        $current_grep_index = 1;
        my $first_file_index = $grep_set[0];
        print "Selecting first matching file (Index $first_file_index). Use 'g+'/'g-' to navigate.\n";

        # Select file and show diffs automatically (assuming cmd_select_file exists)
        cmd_select_file($first_file_index, 1);
    } else {
        print "No files found matching '$regexp' locally.\n";
    }
}

sub get_current_branch {
    # Check if we are in a Git repository
    if (-d ".git") {
        # Executes 'git rev-parse --abbrev-ref HEAD' to get the current branch name
        my $branch = `git rev-parse --abbrev-ref HEAD 2>/dev/null`;
        chomp $branch;
        return $branch;
    }
    return "NOT-IN-GIT";
}

sub cmd_history {
    print "Command History:\n";
    # Show the last 10 commands by default
    my $start = scalar(@command_history) > 10 ? scalar(@command_history) - 10 : 0;

    for my $i ($start .. $#command_history) {
        # Print 1-based index (i + 1) and the command
        printf "  %4d  %s\n", $i + 1, $command_history[$i];
    }
}

# --- NEW HISTORY PROCESSING FUNCTION ---
# Returns the final command string to be executed, or undef if only printing/error.
sub process_history_input {
    my ($input) = @_;

    # 1. Handle history expansion: !! or !N, optionally followed by :p
    if ($input =~ /^\s*(!\d*|!!)(:\S*)?\s*$/) {
        my $history_spec = $1; # e.g., '!!' or '!10'
        my $modifier = $2 || ''; # e.g., ':p'

        my $history_size = scalar(@command_history);
        my $history_index;

        # Determine the target index
        if ($history_spec eq '!!') {
            $history_index = $history_size; # Target is the last command
        } elsif ($history_spec =~ /^!(\d+)$/) {
            $history_index = $1; # Target is the explicit index
        }

        # Check for bounds (1-based index)
        if ($history_index < 1 || $history_index > $history_size) {
            print STDERR "History error: Event number $history_index not found.\n";
            return undef;
        }

        # Get the actual command string (0-based array access)
        my $resolved_command = $command_history[$history_index - 1];

        # Handle the ':p' modifier (Print only)
        if ($modifier eq ':p') {
            print ">> $resolved_command\n";
            return undef; # Do not execute
        }

        # Default: Execute the command
        print ">> $resolved_command\n";
        return $resolved_command;
    }

    # 2. Return the input as-is for normal commands or 'h'
    return $input;
}

sub cmd_select_file_name_regexp {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: f <regexp> or fn <regexp>\n";
        return;
    }

    # Reset/initialize the list of matching files
    my @matched_files = ();

    # Assuming @pr_files is populated with the full list of file paths.
    # We must use the sorted list from cmd_list_files, which is implicit
    # if we rely on the 1-based index that 'lf' uses.
    my @pr_files_sorted = sort @pr_files;

    print "Searching file names for pattern: **'$regexp'**...\n";

    # Iterate through the files tracked in the PR
    for my $i (0 .. $#pr_files_sorted) {
        my $file_name = $pr_files_sorted[$i];
        my $file_index = $i + 1; # 1-based index

        # Perform the regex match on the file path
        # Using 'i' for case-insensitive matching by default (common for file names)
        if ($file_name =~ /$regexp/i) {
            # Store the 1-based index and the file name
            push @matched_files, {
                index => $file_index,
                name  => $file_name
            };
        }
    }

    my $match_count = scalar(@matched_files);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp':\n";

        # List all found files
        foreach my $match (@matched_files) {
            print sprintf(" %4d : %s\n", $match->{index}, $match->{name});
        }

        # Select the first matching file
        my $first_match = $matched_files[0];
        my $first_file_index = $first_match->{index};

        print "\nSelecting first matching file (Index $first_file_index).\n";

        # Select file and show diffs automatically (assuming cmd_select_file exists)
        # Note: $show_diffs=1 is the argument typically used to show diffs immediately.
        cmd_select_file($first_file_index, 1);

    } else {
        print "No files found matching '$regexp' in the PR file list.\n";
    }
}

# --- New Utility for History File Path ---
# Stores history in a dotfile in the current working directory for simplicity.
# This makes the history context-specific to where ghr is run (e.g., inside a repo).
sub get_history_file_path {
    return abs_path('.') . "/.ghr_command_history";
}

# --- Load History from File ---
sub load_history {
    my $history_file = get_history_file_path();

    if (-f $history_file) {
        open my $fh, '<', $history_file or do {
            warn "Warning: Could not open history file for reading: $!\n";
            return;
        };

        # Read history line by line
        my @loaded_history;
        while (my $line = <$fh>) {
            chomp $line;
            push @loaded_history, $line;
        }
        close $fh;

        # Replace the global array, respecting the max size
        # $history_max_size is defined in your global state (default 100)
        @command_history = @loaded_history;
        while (scalar(@command_history) > $history_max_size) {
            shift @command_history;
        }

        print "Loaded " . scalar(@command_history) . " commands from history.\n";
    }
}

# --- Save History to File ---
sub save_history {
    my $history_file = get_history_file_path();

    # Save only the history that fits within the configured maximum size
    my @history_to_save = @command_history;
    while (scalar(@history_to_save) > $history_max_size) {
        shift @history_to_save;
    }

    open my $fh, '>', $history_file or do {
        warn "Warning: Could not open history file for writing: $!\n";
        return;
    };

    # Write each command on a new line
    foreach my $command (@history_to_save) {
        print $fh "$command\n";
    }
    close $fh;

    print "Saved " . scalar(@history_to_save) . " commands to history file.\n";
}
