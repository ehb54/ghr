#!/usr/bin/env perl
use strict;
use warnings;
use Cwd 'abs_path';
use JSON 'decode_json', 'encode_json';
use JSON;

# Global path for session caching
# File::Slurp, Term::ReadLine::Gnu or similar would be needed for a richer experience,
# but for basic CLI in emacs shell, standard IO is fine.

# --- Global State ---
my $current_pr = undef;
my $current_file_index = undef; # 1-based index from 'lf'
my $current_file_name = undef; # Actual file path
my @pr_files = (); # Array of file names for the current PR
my %comments = (
    'global' => [], # Array of global comments: {text => ..., status => 'local'|'pushed'}
    'files' => {}, # Hash: 'path/to/file.txt' => [ {line => ..., pos => ..., text => ..., status => 'local'|'pushed'}, ... ]
    'review_state' => undef # 'approve' | 'request_changes'
);
my %files_data;
my @grep_set = ();      # Array of 1-based file indices that match the last 'g' regexp
my $current_grep_index = undef; # 1-based index into @grep_set
my @command_history = (); # Array to store executed commands
my $history_max_size = 100; # Maximum number of commands to store

# --- Command Dispatch Table ---
# Maps user input to the corresponding subroutine
my %COMMANDS = (
    'q'       => \&cmd_quit,
    '?'       => \&cmd_help,
    'h'       => \&cmd_history,
    'lpr'     => \&cmd_list_prs,
    'lc'      => \&cmd_load_comments,
    'lgc'     => \&cmd_load_general_comments,
    'pr'      => \&cmd_select_pr,
    'lf'      => \&cmd_list_files,
    'fn'      => \&cmd_select_file,
    'f'       => \&cmd_select_file_name_regexp,
    '+'       => \&cmd_select_file,
    '-'       => \&cmd_select_file,
    'dd'      => \&cmd_show_diffs,
    'g'       => \&cmd_grep_diffs,
    'gl'      => \&cmd_grep_local,
    'g+'      => \&cmd_grep_diffs_next,
    'g-'      => \&cmd_grep_diffs_prev,
    'ddiw'    => \&cmd_show_diffs_ignore_whitespace,
    'do'      => \&cmd_show_original,
    'dn'      => \&cmd_show_new,
    'ca'      => \&cmd_add_comment,
    'cd'      => \&cmd_delete_comment,
    'cp'      => \&cmd_push_comments,
    'rs'      => \&cmd_review_summary,
    'accept'  => \&cmd_accept_review,
    'reject'  => \&cmd_reject_review,
    'ajim'    => \&cmd_gemini_chat,
    'agtp'    => \&cmd_openai_chat,
);

# --- GH CLI Check ---
sub check_gh_auth {
    # Check if 'gh' is installed and authenticated by running a simple command
    my $output = `gh auth status 2>&1`;
    if ($? != 0 || $output =~ /not logged into any GitHub hosts/) {
        die "Error: 'gh' command failed or you are not logged in.\nPlease run 'gh auth login'.\n";
    }
    print "GitHub CLI is authenticated.\n";
}
check_gh_auth();

cmd_load_session();

# --- Main Logic ---
sub get_prompt {
    my $prompt = '-'x120 . "\nghr";

    if (defined $current_pr) {
        $prompt .= " \#$current_pr";

        # --- Add File Index and Total Count ---
        if (defined $current_file_name) {
            # 1. Get total count
            my $total_files = scalar(keys %files_data);

            # 2. Get current index (guaranteed to be defined if $current_file_name is defined)
            my $current_index = $current_file_index // 0;

            # Format the prompt segment: [1/100] filename
            $prompt .= sprintf( " [ $current_index/$total_files | %.1f%% ] $current_file_name", 100 * ( $current_index/$total_files ) ) ;
        }
    }

    $prompt .= " > ";
    return $prompt;
}

sub main {
    load_history();
    while (1) {
        # 1. Print the dynamic prompt
        print get_prompt();

        # 2. Read line (Control-D/EOF will result in undef)
        my $raw_input = <STDIN>;
        last unless defined $raw_input; # Exit on EOF (Ctrl-D)

        chomp $raw_input;
        my $user_input = $raw_input;
        $user_input =~ s/^\s+|\s+$//g; # Trim whitespace

        next unless length $user_input; # Skip empty lines

        # 3. History Preprocessing
        # This function resolves !! or !N into the actual command string.
        # It returns undef for history-only commands like 'h' or '!!:p'.
        my $executed_command = process_history_input($user_input);

        # If $executed_command is undef, it means the input was 'h', '!!:p', or an error.
        # We check for 'h' explicitly here because 'process_history_input' only handles '!' expansions.
        if (!defined $executed_command) {
            # Handle 'h' if it wasn't caught by the history processor
            if ($user_input =~ /^\s*h(istory)?\s*$/i) {
                # This ensures 'h' still works if it's not a history expansion.
                cmd_history();
            }
            next; # Skip command dispatch for history print/error
        }

        # 4. Command Dispatch and Execution
        # Use the resolved command for dispatch
        my @parts = split /\s+/, $executed_command, 2;
        my $cmd = lc $parts[0];
        my $args = $parts[1] // '';

        # --- FIX: If command is '+' or '-', set $args to the command itself ---
        # This ensures the '+' command passes '+' as the argument to cmd_select_file
        if (($cmd eq '+' || $cmd eq '-') && $args eq '') {
            $args = $cmd;
        }

        if (my $sub = $COMMANDS{$cmd}) {
            eval {
                $sub->($args);
            };
            if ($@) {
                print "Command Error: $@\n";
            }
        } else {
            print "Unknown command: '$cmd'. Type 'h' for help.\n";
        }

        # 5. Store the executed command in history
        # Store only if it wasn't a history lookup/print and was successfully dispatched (or attempted).
        # We store the fully resolved command string ($executed_command).
        # Note: We skip storing history lookups (like '!!', '!5', 'h') to keep the history clean.
        if ($user_input !~ /^\s*(h(istory)?|!\d*|!!)(:\S*)?\s*$/i) {
            push @command_history, $executed_command;

            # Keep array size bounded
            if (scalar(@command_history) > $history_max_size) {
                shift @command_history;
            }
        }
    }
    save_history();
    print "\nExiting.\n";
}

main(); # Start the program

# --- Command Implementations ---

sub cmd_quit {
    my $unpushed_count = get_unpushed_comment_count();
    if ($unpushed_count > 0) {
        print "Warning: You have $unpushed_count unpushed local comments.\n";
        print "Are you sure you want to quit without pushing? (y/N): ";
        my $confirm = <STDIN>;
        return unless $confirm =~ /^[yY]/;
    }

    # --- SAVE SESSION STATE ---
    if (defined $current_pr && defined $current_file_name) {
        my $session_file_path = get_session_file_path();
        my $session_data = {
            pr_num => $current_pr,
            file_name => $current_file_name
        };

        # Use an outer scope to capture any file/JSON errors gracefully
        eval {
            open(my $fh, '>', $session_file_path) or die "Could not open file '$session_file_path': $!";
            print $fh JSON->new->pretty(1)->encode($session_data);
            close $fh;
            print "Session state saved to $session_file_path\n";
        };
        if ($@) {
            print "Warning: Failed to save session state: $@\n";
        }
    }

    exit 0;
}

sub cmd_help {
    print <<'HELP_TEXT';
## GitHub Review CLI (ghr) Help

q         // quit (or control-D/EOF)
h         // command history
?         // print this help
lpr       // list PRs (Uses 'gh pr list')
pr PR#    // select PR (e.g., 'pr 123')
lf        // list files in the current PR
lc        // list pushed comments in the current PR
lgc       // list global comments in the current PR
fn file#  // select file by number, or use '+' or '-' for next/previous
f name    // file by name regex
+         // select next file and show diffs
-         // select previous file and show diffs
dd        // show diffs for selected file
ddiw      // show diffs for selected file ignore whitespace
do        // show original lines for selected file (with line numbers)
dn        // show new lines for selected file (with positional info)
g regexp  // grep diffs and list files and their file numbers that match
gl regexp // grep local files
g+        // select next file from last g set
g-        // select previous file from last g set
ca pos    // add comment. 'pos' is position # from 'sn', or 'g' for global.
cd pos    // delete comment by position # or 'g' for global.
cp        // pushes all local comments to GitHub (asks confirmation)
rs        // review summary (all local and pushed comments)
accept    // accept PR (asks confirmation, pushes comments)
reject    // reject PR (asks confirmation, pushes comments)

HELP_TEXT
}

sub cmd_list_prs {
    print "Fetching list of open pull requests...\n";
    # Simple call, Emacs shell handles pagination
    system('gh pr list --state open --limit 50');
}

sub cmd_select_pr {
    my ($pr_num, $filenumber) = @_;
    $filenumber = 1 if !$filenumber;
    if ($pr_num =~ /^\d+$/) {
        # Check if PR is valid and get *all* files using the API
        # This bypasses the 100-file limit of 'gh pr view'
        # The --jq flag filters to just the filenames, one per line.
        @pr_files = `gh api --paginate "repos/{owner}/{repo}/pulls/$pr_num/files" --jq ".[].filename" 2>/dev/null`;
        
        if ($? != 0) {
            print "Error: PR #$pr_num not found or inaccessible.\n";
            return;
        }

        # Clear existing state and comments
        $current_pr = $pr_num;
        $current_file_index = undef;
        $current_file_name = undef;
        %comments = (
            'global'     => [],
            'files'      => {},
            'review_state' => undef
        );

        # No longer need decode_json or map, @pr_files is now a simple list.

        # --- POPULATE %files_data ---
        # Iterate through the returned file paths and populate the global hash.
        # The value can be a placeholder (like 1) or a hash of metadata if needed later.
        my $file_count = 0;
        foreach my $file_path (@pr_files) {
            chomp $file_path;

            # Trim surrounding quotes that gh/jq adds
            $file_path =~ s/^"|"$//g;
            
            # Skip empty lines if any
            next if !$file_path;

            # Store the file path as a key in the global hash
            $files_data{$file_path} = 1; # Storing 1 as a placeholder status
            $file_count++;
        }

        # Add existing comments for a richer experience (optional but good)
        # my $existing_comments = `gh pr review $pr_num --json comments`;
        # ... logic to parse and load existing comments ...

        print "Selected PR #$current_pr with $file_count files.\n";
        cmd_select_file( 1, $filenumber ) if $filenumber > 0 && $filenumber <= $file_count;
    } else {
        print "Usage: pr <PR#>\n";
    }
}

sub cmd_list_files {
    if (!defined $current_pr) {
        print "No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }
    print "Files in PR #$current_pr:\n";
    for my $i (0 .. $#pr_files) {
        my $status = defined $comments{files}{$pr_files[$i]} ? "(C)" : ""; # Commented
        print sprintf(" %2d: %s %s\n", $i + 1, $pr_files[$i], $status);
    }
}

# --- Utility Functions (Place after commands) ---

sub get_unpushed_comment_count {
    my $count = scalar grep { $_->{status} eq 'local' } @{$comments{global}};
    for my $file (keys %{$comments{files}}) {
        $count += scalar grep { $_->{status} eq 'local' } @{$comments{files}{$file}};
    }
    return $count;
}

sub cmd_select_file {
    my ($arg, $quiet) = @_; # $arg is now correctly '+', '-', a number, or ''

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    # IMPORTANT: Use the global file list variable
    # NOTE: @pr_files must be populated in cmd_select_pr()
    my @pr_files = sort keys %files_data;
    my $max_index = scalar(@pr_files);

    my $new_index;
    my $is_nav_command = 0; # Flag to determine if a diff should be shown

    # 1. Check for '+'
    if ($arg eq '+') {
        # If no file is selected yet, start from index 1 (the first file)
        $new_index = (defined $current_file_index) ? $current_file_index + 1 : 1;
        if ($new_index > $max_index) {
            print "End of file list reached (at file $max_index).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 2. Check for '-'
    elsif ($arg eq '-') {
        # If no file is selected, cannot go backward
        if (!defined $current_file_index) {
            print "No file currently selected. Cannot move backward.\n";
            return;
        }
        $new_index = $current_file_index - 1;
        if ($new_index < 1) {
            print "Beginning of file list reached (at file 1).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 3. Check for file number
    elsif ($arg =~ /^\d+$/) {
        $new_index = $arg;
        if ($new_index < 1 || $new_index > $max_index) {
            print "Error: File number $arg is out of range (1-$max_index).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 4. Handle Usage (This is only hit when user types 'sf' with no argument, $arg is '')
    elsif ($arg eq '') {
        print "Usage: sf <file#> | + | -\n";
        return;
    }
    else {
        # Catch all for unrecognized arguments like 'sf abc'
        print "Unrecognized argument for file selection: '$arg'.\n";
        return;
    }

    # --- Update state ---
    $current_file_index = $new_index;
    $current_file_name = $pr_files[$current_file_index - 1]; # Convert 1-based index to 0-based array index

    print "Selected file **$current_file_name** ($current_file_index/$max_index).\n";

    # Display any existing comments for the file (your existing logic)
    if (exists $comments{files}{$current_file_name} && @{$comments{files}{$current_file_name}}) {
        # ... (comment printing logic) ...
        print "\nLocal/Pushed comments for this file:\n";
        foreach my $c (@{$comments{files}{$current_file_name}}) {
            my $status = ($c->{status} eq 'local') ? '[LOCAL]' : '[PUSHED]';
            print "  $status Pos: $c->{pos}, Line: $c->{line} -> \"$c->{text}\"\n";
        }
        print "\n";
    }

    # --- Run 'sd' automatically for navigation commands ---
    # This runs the diff for '+', '-', and 'sf #' commands
    if ($is_nav_command && !$quiet) {
        cmd_show_diffs();
    }
}

# --- Utility: Retrieve the raw diff for a specific or current file (REFACTORED) ---
# Argument: Optional file name string
sub get_file_diff_content {
    my ($file_name_override) = @_;
    
    my $target_file = $file_name_override || $current_file_name;

    if (!defined $current_pr || !defined $target_file) {
        return undef, "Error: No PR or file selected.\n";
    }

    # 1. Fetch the full diff for the PR (runs only once per command execution)
    my $cmd = "gh pr diff $current_pr 2>&1";
    my $full_diff = `$cmd`;

    if ($? != 0) {
        return undef, "Error running 'gh pr diff': $full_diff\n";
    }

    # 2. Use a regex match to find the start and stop of the file section
    my $escaped_file_name = quotemeta($target_file);
    
    # This regex captures the content for $target_file
    if ($full_diff =~ /(diff --git a\/$escaped_file_name.*?)(\ndiff --git a\/|\z)/s) {
        my $file_diff = $1;
        return $file_diff, "";
    }
    
    # Fallback/Error case
    return undef, "Error: Could not find diff section for file **$target_file** in PR #$current_pr.\n";
}

sub cmd_show_diffs {
    # Call without argument uses $current_file_name
    my ($diff, $err) = get_file_diff_content(); 
    if ($err) { print $err; return; }
    print "$diff\n";
}

sub cmd_show_original {
    my ($diff, $err) = get_file_diff_content();
    if ($err) {
        print $err;
        return;
    }

    my ($original_line, $new_line) = (0, 0);
    my $is_new_file = 0; # Flag to check if the file is new

    print "\n--- Original Changed Lines in $current_file_name ---\n";

    foreach my $line (split /\n/, $diff) {
        # Check for 'new file mode' to confirm it's a new file (optional, but good)
        if ($line =~ /^new file mode/) {
            $is_new_file = 1;
        }

        # Hunk header: @@ -<Original_Start>,<Original_Count> +<New_Start>,<New_Count> @@
        if ($line =~ /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/) {
            $original_line = $1;
            $new_line = $2;
            
            if ($original_line == 0) {
                print "\n-- Hunk starts (New File: No original lines to show) --\n";
                # If original line starts at 0, it's a new file (or an empty file start)
                next; 
            }
            
            print "\n-- Hunk starts (Original Line $original_line) --\n";
            next;
        }

        # Skip non-hunk-related lines that aren't content (like header lines)
        next if $line !~ /^[ \-+\\]/;

        # Context line: start with ' '
        if ($line =~ /^\s/) {
            $original_line++;
            $new_line++;
            next;
        }

        # Original (Removed) line: starts with '-'
        elsif ($line =~ /^-/) {
            # Only print if this is NOT a new file (i.e., if it's a removal or modification)
            if (!$is_new_file) {
                print sprintf("%4d: %s\n", $original_line, substr($line, 1));
            }
            $original_line++;
            next;
        }

        # New (Added) line: starts with '+'
        elsif ($line =~ /^\+/) {
            $new_line++;
            next;
        }
    }
    
    if ($is_new_file) {
        print "\nFile **$current_file_name** is a new file. No 'Original' lines exist.\n";
    }
}

sub cmd_show_new {
    my ($diff, $err) = get_file_diff_content();
    if ($err) {
        print $err;
        return;
    }

    my ($new_line, $position) = (0, 0);
    my $is_removed_file = 0; # Flag to check if the file is removed

    print "\n--- New Changed Lines in $current_file_name (for 'ca' command) ---\n";

    foreach my $line (split /\n/, $diff) {
        # Check for 'deleted file mode'
        if ($line =~ /^deleted file mode/) {
            $is_removed_file = 1;
        }

        # Hunk header: Reset counters
        if ($line =~ /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/) {
            $new_line = $2;
            $position = 0; # Position is relative to the start of the current hunk
            
            if ($new_line == 0) {
                print "\n-- Hunk starts (Removed File: No new lines to comment) --\n";
                next;
            }
            
            print "\n-- Hunk starts (New Line $new_line) --\n";
            next;
        }

        # Skip non-hunk-related lines that aren't content (like header lines)
        next if $line !~ /^[ \-+\\]/;

        # Context line: start with ' '
        if ($line =~ /^\s/) {
            $new_line++;
            $position++;
            # For context lines, print only for reference, not for commenting
            print sprintf("%4s:%4d: %s\n", '', $new_line, substr($line, 1));
            next;
        }

        # Original (Removed) line: starts with '-'
        elsif ($line =~ /^-/) {
            # Removed lines *do* increment position, but cannot be commented on directly
            $position++;
            # For removed lines, print only for reference
            print sprintf("%4s:%4s: %s\n", '', '-', substr($line, 1));
            next;
        }

        # New (Added) line: starts with '+'
        elsif ($line =~ /^\+/) {
            # Only + lines get comment positions
            print sprintf("%4d:%4d: %s\n", $position, $new_line, substr($line, 1));
            $new_line++;
            $position++;
            next;
        }
    }
    
    if ($is_removed_file) {
        print "\nFile **$current_file_name** is a removed file. Comments can only be added to lines that still exist.\n";
    } else {
        print "\nNote: Use the **first column number** (Position #) with 'ca' command.\n";
    }
}

sub cmd_add_comment {
    my ($args) = @_;
    my ($pos, $initial_text) = split /\s+/, $args, 2;
    $pos = lc $pos;
    
    # 1. Input Validation and Target Determination
    if (!defined $pos || ($pos ne 'g' && $pos !~ /^\d+$/)) {
        print "Usage: ca <position # | g> [initial comment text]\n";
        print "  'g' is for a global review comment.\n";
        print "  Position # is found via the 'sn' command.\n";
        return;
    }

    my $target_type;
    my $target_key;
    my $line_num_for_push = undef; # The actual line number, needed for the gh comments.json

    if ($pos eq 'g') {
        $target_type = 'global';
        $target_key = 'global';
        print "Adding a GLOBAL comment. Type your comment, terminate with a '.' on a single line:\n";
    } else {
        # Positional Comment Check
        if (!defined $current_file_name) {
            print "Error: Cannot add positional comment. No file selected. Use 'sf' first.\n";
            return;
        }
        $target_type = 'positional';
        $target_key = $current_file_name;
        
        # We need to find the corresponding actual line number ($new_line) for the given $pos
        # This requires re-running the 'sn' logic, but just to map pos -> line
        ($line_num_for_push, my $valid) = _map_pos_to_line($pos, $current_file_name);
        if (!$valid) {
            print "Error: Position #$pos is invalid for file **$current_file_name**. Use 'sn' to see valid positions.\n";
            return;
        }

        print "Adding comment at position **$pos** (Line $line_num_for_push) in **$current_file_name**.\n";
        print "Type your comment, terminate with a '.' on a single line:\n";
    }

    # 2. Collect Multiline Input
    my $comment_text = defined $initial_text ? $initial_text : "";
    
    # If there was an initial text, add a newline before starting multiline input
    $comment_text .= "\n" if $comment_text ne ""; 

    while (<STDIN>) {
        chomp;
        last if $_ eq '.';
        $comment_text .= "$_\n";
    }

    # 3. Store the Comment
    my $new_comment = {
        text   => $comment_text,
        status => 'local', # Always starts as local
        pos    => $pos,    # 'g' or position number
        # Only set file-specific data for positional comments
        ($target_type eq 'positional' ? (
            file => $current_file_name,
            line => $line_num_for_push
        ) : ())
    };

    # Ensure the file entry exists in %comments
    if ($target_type eq 'positional' && !exists $comments{files}{$target_key}) {
        $comments{files}{$target_key} = [];
    }

    # Push the new comment into the data structure
    my $storage = ($target_type eq 'global') ? $comments{global} : $comments{files}{$target_key};
    push @$storage, $new_comment;

    print "\nComment added successfully (local: $target_type, pos: $pos).\n";
}

# --- Utility to map position to line number (CORRECTED) ---
# This is crucial for building the 'gh pr review --comments' JSON later.
sub _map_pos_to_line {
    my ($target_pos, $file_name) = @_;
    
    # Pass the required $file_name to the refactored utility
    my ($diff, $err) = get_file_diff_content($file_name);
    return undef, 0 if $err; 

    my ($new_line, $position) = (0, 0);

    # ... (The rest of the parsing logic remains identical to the previous implementation) ...
    
    foreach my $line (split /\n/, $diff) {
        if ($line =~ /^@@ .* \+(\d+)(?:,\d+)? @@/) {
            $new_line = $1;
            $position = 0;
            next;
        }

        if ($line =~ /^\s/ || $line =~ /^-/) {
            $position++;
            $new_line++ if $line =~ /^\s/;
            next;
        }
        
        if ($line =~ /^\+/) {
            if ($position eq $target_pos) {
                return $new_line, 1; 
            }
            $new_line++;
            $position++;
            next;
        }
    }
    
    return undef, 0; 
}

sub cmd_delete_comment {
    my ($pos) = @_;
    $pos = lc $pos;

    # 1. Input Validation and Target Determination
    if (!defined $pos || ($pos ne 'g' && $pos !~ /^\d+$/)) {
        print "Usage: cd <comment_index | g>\n";
        print "  'g' deletes a GLOBAL comment (requires index).\n";
        print "  Comment index is found by listing comments (e.g., using 'rs' or 'sf').\n";
        return;
    }
    
    my $target_type;
    my $comment_storage;

    if ($pos eq 'g') {
        $target_type = 'global';
        $comment_storage = $comments{global};
        print "Existing GLOBAL comments:\n";
    } else {
        if (!defined $current_file_name) {
            print "Error: Cannot delete positional comment. No file selected. Use 'sf' first.\n";
            return;
        }
        $target_type = 'positional';
        $comment_storage = $comments{files}{$current_file_name} // [];
        print "Existing comments in **$current_file_name**:\n";
    }
    
    if (!@$comment_storage) {
        print "No $target_type comments exist to delete.\n";
        return;
    }

    # 2. List Comments and Get Index
    # Use a loop to list the comments with an index for deletion
    my @indices_to_delete;
    for my $i (0 .. $#$comment_storage) {
        my $c = $comment_storage->[$i];
        my $status = ($c->{status} eq 'local') ? '[L]' : '[P]';
        my $info = ($target_type eq 'positional') ? "Pos: $c->{pos}, Line: $c->{line}" : "";
        print sprintf(" [%2d] %s %s: %s\n", $i + 1, $status, $info, substr($c->{text}, 0, 50) . '...');
    }
    
    print "\nEnter the **index number** (1 to " . scalar(@$comment_storage) . ") to delete, or 'a' for all, or 'c' to cancel: ";
    my $delete_input = <STDIN>;
    chomp $delete_input;

    if ($delete_input =~ /^\d+$/) {
        my $idx = $delete_input - 1; # Convert 1-based to 0-based
        if ($idx >= 0 && $idx <= $#$comment_storage) {
            push @indices_to_delete, $idx;
        } else {
            print "Error: Invalid index.\n";
            return;
        }
    } elsif (lc $delete_input eq 'a') {
        @indices_to_delete = (0 .. $#$comment_storage);
    } else {
        print "Deletion cancelled.\n";
        return;
    }

    # 3. Perform Deletion (in reverse order to preserve indices)
    @indices_to_delete = sort {$b <=> $a} @indices_to_delete; # Sort descending
    
    my $deleted_count = 0;
    foreach my $idx (@indices_to_delete) {
        splice(@$comment_storage, $idx, 1);
        $deleted_count++;
    }

    # Clean up file entry if all comments were removed
    if ($target_type ne 'global' && !@$comment_storage) {
        delete $comments{files}{$current_file_name};
    }
    
    print "Successfully deleted $deleted_count $target_type comment(s).\n";
}

sub cmd_review_summary {
    print "\n======================================================\n";
    print "### üìã REVIEW SUMMARY for PR #$current_pr ###\n";
    print "======================================================\n";

    # --- 1. Review Status ---
    my $review_state = $comments{review_state} // 'PENDING';
    print "Review Status: **$review_state**\n";
    print "------------------------------------------------------\n";

    # --- 2. Global Comments ---
    my @global_comments = @{$comments{global}};
    if (@global_comments) {
        print "### üåé Global Comments: (" . scalar(@global_comments) . ") ###\n";
        
        my $local_count = 0;
        my $pushed_count = 0;
        
        for my $i (0 .. $#global_comments) {
            my $c = $global_comments[$i];
            my $status = $c->{status};
            
            if ($status eq 'local') {
                $local_count++;
            } else {
                $pushed_count++;
            }
            
            # Use index + 1 for user readability when referencing with 'cd g'
            print sprintf(" [%2d] %s: %s\n", $i + 1, uc($status), $c->{text});
        }
        
        print "  -> Summary: **$local_count Local**, **$pushed_count Pushed**\n";
        print "------------------------------------------------------\n";
    } else {
        print "### üåé Global Comments: None ###\n";
        print "------------------------------------------------------\n";
    }

    # --- 3. File Positional Comments ---
    my @commented_files = sort keys %{$comments{files}};
    
    if (@commented_files) {
        print "### üìÇ File Positional Comments: (" . scalar(@commented_files) . " files) ###\n";
        
        my $total_local_count = 0;
        my $total_pushed_count = 0;

        foreach my $file_name (@commented_files) {
            my @file_comments = @{$comments{files}{$file_name}};
            next unless @file_comments;
            
            print "\nFile: **$file_name** (" . scalar(@file_comments) . " comments)\n";

            my $file_local_count = 0;
            my $file_pushed_count = 0;
            
            for my $i (0 .. $#file_comments) {
                my $c = $file_comments[$i];
                my $status = $c->{status};
                
                if ($status eq 'local') {
                    $file_local_count++;
                } else {
                    $file_pushed_count++;
                }

                # Use index + 1 for user readability when referencing with 'cd'
                print sprintf(" [%2d] %s (Pos: %-4s | Line: %-4s) %s\n", 
                    $i + 1, uc($status), $c->{pos}, $c->{line}, $c->{text});
            }
            
            $total_local_count += $file_local_count;
            $total_pushed_count += $file_pushed_count;
        }

        print "\n--- TOTAL POSITIONAL SUMMARY ---\n";
        print "  -> **$total_local_count Local** comments across " . scalar(@commented_files) . " files.\n";
        print "  -> **$total_pushed_count Pushed** comments.\n";
        print "------------------------------------------------------\n";
    } else {
        print "### üìÇ File Positional Comments: None ###\n";
        print "------------------------------------------------------\n";
    }
}

use File::Temp 'tempfile';

# Utility: Builds the comments.json file required by 'gh pr review'
# Returns: The path to the temporary JSON file, or undef on error.
sub build_comments_json {
    my @gh_comments = ();

    # Iterate through all files that have comments
    foreach my $file_name (keys %{$comments{files}}) {
        my @file_comments = @{$comments{files}{$file_name}};
        
        # Filter for only local, unpushed comments
        foreach my $c (@file_comments) {
            next unless $c->{status} eq 'local';
            
            # The 'gh pr review' API requires the following structure:
            # - path: The file path
            # - position: The position offset from the start of the hunk (found via 'sn')
            # - body: The comment text
            push @gh_comments, {
                path     => $c->{file},
                position => $c->{pos},
                body     => $c->{text},
                # NOTE: line is not strictly required if position is provided,
                # but including the line number can sometimes improve reliability.
                line     => $c->{line}
            };
        }
    }

    # If no positional comments are local, return undef (no file needed)
    return undef unless @gh_comments;

    # Create a temporary file to hold the JSON data
    my ($fh, $filename) = tempfile(
        "ghr_comments_XXXXXX", 
        DIR => "/tmp", # Use /tmp or a dedicated directory
        UNLINK => 1   # Important: Unlink immediately so it's deleted when the file handle closes
    );
    
    # Write the JSON data to the file
    my $json_data = encode_json(\@gh_comments);
    print $fh $json_data;
    close $fh;
    
    print "Created temporary comments JSON file: $filename\n";
    return $filename;
}

# Utility: Updates the status of all local comments to 'pushed'
sub _mark_local_comments_as_pushed {
    # Mark global comments
    for my $c (@{$comments{global}}) {
        $c->{status} = 'pushed' if $c->{status} eq 'local';
    }

    # Mark positional comments
    foreach my $file_name (keys %{$comments{files}}) {
        for my $c (@{$comments{files}{$file_name}}) {
            $c->{status} = 'pushed' if $c->{status} eq 'local';
        }
    }
}

# Utility: Builds a single file containing both the global review body and 
#          the positional comments in the format required by 'gh pr review'.
# Returns: The path to the temporary body file, or undef if no comments/status to push.
sub _prepare_unified_body_file {
    my ($review_type) = @_; # 'comment', 'approve', or 'request_changes'
    
    my @global_local_comments = grep { $_->{status} eq 'local' } @{$comments{global}};
    my $has_local_positional = get_unpushed_comment_count() > scalar(@global_local_comments);
    
    # If no local comments and no explicit approval/rejection, nothing to push
    unless (scalar(@global_local_comments) > 0 || $has_local_positional || $review_type ne 'comment') {
        return undef;
    }
    
    # --- 1. Build the Review Body (Global Comments) ---
    my $review_body = "";
    if (@global_local_comments) {
        $review_body = join("\n---\n", map { "GLOBAL COMMENT:\n" . $_->{text} } @global_local_comments);
    } elsif ($review_type ne 'comment') {
        # If we are accepting/rejecting, provide a default minimal body if no global comments exist
        $review_body = "Review submitted via interactive CLI.";
    }

    # --- 2. Build the Positional Comments Section ---
    my $comments_section = "";
    if ($has_local_positional) {
        $comments_section .= "\n\n## Comments\n";
        
        # Iterate through all files that have local comments
        foreach my $file_name (keys %{$comments{files}}) {
            my @file_comments = @{$comments{files}{$file_name}};
            
            # Filter for only local, unpushed comments
            foreach my $c (grep { $_->{status} eq 'local' } @file_comments) {
                # gh pr review positional comments require line or position. We use line (safer).
                # The format uses YAML list syntax.
                $comments_section .= sprintf("- path: %s\n", $c->{file});
                $comments_section .= sprintf("  line: %s\n", $c->{line}); 
                $comments_section .= sprintf("  body: %s\n", $c->{text});
            }
        }
    }
    
    # --- 3. Create the Temporary File ---
    my ($fh, $temp_file) = tempfile("ghr_unified_XXXXXX", DIR => "/tmp", UNLINK => 1);
    print $fh $review_body;
    print $fh $comments_section;
    close $fh;
    
    return $temp_file;
}

sub cmd_push_comments {
    my $unpushed_count = get_unpushed_comment_count();

    if ($unpushed_count == 0) {
        print "No new local comments to push for PR #$current_pr.\n";
        return;
    }
    
    print "\nYou have **$unpushed_count** local comments (global and positional).\n";
    print "Are you sure you want to push these comments to GitHub now? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    return unless $confirm =~ /^[yY]/;
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file('comment'); # Pass 'comment' review type
    
    unless (defined $temp_file) {
        print "Error: Failed to create unified comment body file.\n";
        return;
    }
    
    # --- 2. Execute Command (gh pr review) ---
    # The combination of '--comment' and '--body-file' is the correct syntax
    # for a comment-only submission without changing the review status.
    my @cmd_parts = ("gh", "pr", "review", $current_pr, "--comment", "--body-file", $temp_file);

    print "\nPushing comments via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully pushed all $unpushed_count comment(s) to PR #$current_pr.\n";
        _mark_local_comments_as_pushed();
    } else {
        print "\n‚ùå Error pushing comments. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

sub cmd_accept_review {
    return unless defined $current_pr;
    $comments{review_state} = 'APPROVE';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting an **APPROVAL** of PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('approve');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Approval submission cancelled.\n";
    }
}

sub cmd_reject_review {
    return unless defined $current_pr;
    $comments{review_state} = 'REQUEST_CHANGES';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting a **REQUEST FOR CHANGES** on PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('request_changes');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Rejection submission cancelled.\n";
    }
}

sub _submit_review {
    my ($review_type) = @_; # 'approve' or 'request_changes'
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file($review_type);

    # If no comments and no body file, we still submit the state, but gh may fail without a body file.
    # To be safe, we always generate a body file, even if minimal.
    unless (defined $temp_file) {
        # Fallback: Create a minimal body file if _prepare_unified_body_file returned undef
        my $default_body = $review_type eq 'approve' ? "Approved." : "Changes requested.";
        my ($fh, $filename) = tempfile("ghr_minimal_XXXXXX", DIR => "/tmp", UNLINK => 1);
        print $fh $default_body;
        close $fh;
        $temp_file = $filename;
    }

    # --- 2. Execute Command ---
    my $flag = ($review_type eq 'approve') ? '--approve' : '--request-changes';
    
    my @cmd_parts = ("gh", "pr", "review", $current_pr, $flag, "--body-file", $temp_file);
    
    print "\nSubmitting review via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully submitted review as " . uc($review_type) . " for PR #$current_pr.\n";
        # Mark all local comments as pushed
        _mark_local_comments_as_pushed();
        $comments{review_state} = uc($review_type);
    } else {
        # Revert state on failure
        $comments{review_state} = 'PENDING';
        print "\n‚ùå Error submitting review. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

sub cmd_load_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching submitted review comments for PR #$current_pr...\n";

    # --- 1. Get the repository path (owner/repo) using GH context variables ---
    # This path resolves the current repository context using {owner} and {repo}.
    my $repo_path_cmd = "gh api repos/{owner}/{repo} --jq '.full_name' 2>/dev/null";

    # For debugging: print "cmd: $repo_path_cmd\n"; 

    my $repo_path = `$repo_path_cmd`;
    chomp $repo_path;

    # Check the result. It should now return "ehb54/ultrascan3"
    if ($? != 0 || !$repo_path || $repo_path !~ /\//) {
        print "Error: Failed to determine repository path (owner/repo) using 'gh api'. Check your current directory and authentication.\n";
        return;
    }
    
    # Clean up any potential surrounding quotes from the jq output
    $repo_path =~ s/^"|"$//g;
    
    # --- 2. API Call to Fetch Positional Comments ---
    # Use the retrieved $repo_path to call the GitHub REST API.
    my $api_cmd = "gh api repos/$repo_path/pulls/$current_pr/comments --jq '
        .[] | {
            user: .user.login,
            body: .body,
            path: .path,
            line: .line,
            position: .position,
            created_at: .created_at
        }'";

    my $json_output = `$api_cmd`;
    
    if ($? != 0) {
        print "Error: Failed to fetch comments via gh api. Check permissions and 'gh auth status'.\n";
        return;
    }

    # --- 3. Parse and Display (Logic remains the same) ---
    my @comments_data = ();
    
    # gh api + jq returns a stream of JSON objects; split by newline and parse each
    foreach my $json_line (split /\n/, $json_output) {
        next unless $json_line =~ /^{/;
        eval {
            push @comments_data, decode_json($json_line);
        };
        if ($@) {
            print "Warning: Failed to parse comment JSON: $@\n";
        }
    }

    if (!@comments_data) {
        print "No submitted positional review comments found for PR #$current_pr.\n";
        return;
    }
    
    # Sort by file path and then line number for clean display
    @comments_data = sort { 
        $a->{path} cmp $b->{path} || $a->{line} <=> $b->{line} 
    } @comments_data;

    print "\n### üí¨ Submitted Comments by Other Reviewers ###\n";
    print "------------------------------------------------------\n";

    my $current_path = "";
    foreach my $c (@comments_data) {
        if ($c->{path} ne $current_path) {
            $current_path = $c->{path};
            print "\nFile: **$current_path**\n";
        }

        my $date_str = substr($c->{created_at}, 0, 10);
        
        print sprintf(" %-15s (Line: %-4s | Pos: %-4s) [%s]\n", 
            $c->{user}, $c->{line}, $c->{position}, $date_str
        );
        # Use simple indentation for the body
        my $body_preview = (split /\n/, $c->{body})[0];
        print "    > $body_preview...\n";
    }
    print "------------------------------------------------------\n";
}

sub cmd_load_general_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching general discussion comments for PR #$current_pr...\n";

    # Use gh pr view --json comments to get the list of PR discussion comments
    my $cmd = "gh pr view $current_pr --json comments 2>/dev/null";

    my $json_output = `$cmd`;
    
    if ($? != 0) {
        print "Error: Failed to execute 'gh pr view --json comments'.\n";
        return;
    }

    my $data;
    eval {
        $data = decode_json($json_output);
    };

    if ($@ || !defined $data->{comments} || !ref $data->{comments}) {
        print "Error: Failed to parse general comments JSON.\n";
        return;
    }

    my @comments = @{$data->{comments}};

    if (!@comments) {
        print "No general discussion comments found for PR #$current_pr.\n";
        return;
    }
    
    print "\n### üí¨ General PR Discussion Comments (" . scalar(@comments) . ") ###\n";
    print "------------------------------------------------------\n";

    # Display comments in reverse chronological order (newest first)
    @comments = sort { $b->{createdAt} cmp $a->{createdAt} } @comments;

    for my $c (@comments) {
        my $user = $c->{author}->{login} // 'Unknown User';
        my $date_str = substr($c->{createdAt}, 0, 10);
        my $body = $c->{body} // 'No body content.';
        
        # Display the header and a short preview
        print sprintf("\n[%s] Comment by **%s** on %s\n", 
            $c->{id} || 'N/A', $user, $date_str
        );
        
        # Use a blockquote for the body content
        my @body_lines = split /\n/, $body;
        my $preview_lines = 0;
        
        for my $line (@body_lines) {
            # Skip empty lines that might start the body
            next if $line =~ /^\s*$/ && $preview_lines == 0; 
            
            # Print up to 64 lines of preview
            print "    > $line\n";
            $preview_lines++;
            last if $preview_lines >= 64;
        }

        # Indicate if the comment was truncated
        print "    > ... (truncated) ...\n" if scalar(@body_lines) > $preview_lines;
    }
    print "------------------------------------------------------\n";
}

sub cmd_show_diffs_ignore_whitespace {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }
    if (!defined $current_file_name) {
        print "Error: No file selected. Use 'sf <file#>' or '+' first.\n";
        return;
    }

    # --- 1. Ensure the PR's head commit is local (Required to avoid 'bad object') ---
    print "Ensuring PR #$current_pr history is available locally...\n";
    
    # Use git fetch with the PR refspec to pull down the required commits without checking out the branch.
    # The refspec format is 'pull/<PR_NUM>/head'.
    my @fetch_cmd = ("git", "fetch", "origin", "pull/$current_pr/head:refs/pr_temp/$current_pr");
    
    print "Executing: @fetch_cmd\n";
    # We use system for git commands that modify the local repo state (like fetch)
    system(@fetch_cmd); 
    
    if ($? != 0) {
        print "\nError: Failed to fetch PR #$current_pr head commits. Cannot proceed with diff.\n";
        return;
    }
    print "Fetch complete.\n";

    # --- 2. Fetch the necessary commit SHAs using gh pr view ---
    print "Fetching base and head commit SHAs...\n";
    
    # We need baseRefOid (the base branch's commit) and headRefOid (the PR branch's commit)
    my $sha_cmd = "gh pr view $current_pr --json baseRefOid,headRefOid 2>/dev/null";
    my $json_output = `$sha_cmd`;

    # ... (Error handling and JSON parsing remains the same) ...
    my $data;
    eval { $data = decode_json($json_output); };
    if ($@ || !defined $data->{baseRefOid} || !defined $data->{headRefOid}) {
        print "Error: Failed to parse commit SHAs from gh CLI output.\n";
        return;
    }
    
    my $base_sha = $data->{baseRefOid};
    my $head_sha = $data->{headRefOid};
    
    print "Diff (ignoring whitespace) for file: **$current_file_name**\n";

    # --- 3. Execute the raw 'git diff' command ---
    my @diff_cmd_parts = (
        "git",
        "diff",
        "--ignore-all-space", # The desired flag
        "$base_sha",          # Base commit SHA
        "$head_sha",          # Head commit SHA
        "--",                 # Separator
        $current_file_name    # File path
    );
    
    system(@diff_cmd_parts);
    
    # --- 4. Cleanup (Optional, but recommended) ---
    # Delete the temporary fetched reference after the diff is done.
    system("git", "update-ref", "-d", "refs/pr_temp/$current_pr");
}

sub cmd_load_session {
    my $session_file_path = get_session_file_path();

    # Check if the session file exists
    unless (-e $session_file_path) {
        print "No previous session found.\n";
        return;
    }

    print "Attempting to load previous session from $session_file_path...\n";

    my $data;
    eval {
        # Read the JSON file
        local $/; # Enable slurp mode
        open(my $fh, '<', $session_file_path) or die "Could not open file: $!";
        my $json_text = <$fh>;
        close $fh;

        # Decode the JSON
        $data = decode_json($json_text);
    };

    if ($@) {
        print "Warning: Failed to load or parse session file: $@\n";
        return;
    }

    # --- Restore State ---
    my $pr_num = $data->{pr_num} // undef;
    my $file_name = $data->{file_name} // undef;

    if (defined $pr_num) {
        print "Restoring PR #$pr_num.\n";

        # We must call cmd_select_pr to populate %files_data and $current_pr
        cmd_select_pr($pr_num, -1); # -1 prevents selecting a file

        if (defined $file_name && defined $current_pr) {
            # Find the index of the saved file name within the newly loaded file list
            my @pr_files = sort keys %files_data;
            my $found_index = 0;

            for my $i (0 .. $#pr_files) {
                if ($pr_files[$i] eq $file_name) {
                    $found_index = $i + 1; # Convert 0-based to 1-based index
                    last;
                }
            }

            if ($found_index > 0) {
                print "Restoring file: $file_name (index $found_index).\n";
                # Call cmd_select_file to select the file and show the diff
                # Note: We must call cmd_select_file with the index, not the file name
                cmd_select_file($found_index, 1);
            } else {
                print "Warning: File '$file_name' not found in PR \#{$pr_num}'s file list.\n";
            }
        }
    }
}

sub get_session_file_path {
    my $home = $ENV{HOME} || $ENV{USERPROFILE} || die "Could not determine home directory (neither HOME nor USERPROFILE set)";
    return "$home/.ghr_session.json";
}

#!/usr/bin/perl
#
# This script defines and runs the cmd_gemini_chat function, which initiates
# a continuous, interactive, and stateful (conversational) session with the
# Gemini API using the GeminiConverse module.
#
# PREREQUISITES:
# 1. The GEMINI_API_KEY environment variable must be set.
# 2. The GeminiConverse.pm module must be in the same directory or in PERL's @INC.
# 3. Ensure your terminal is set to UTF-8 (though we are bypassing most of that
#    complexity by focusing on the logic here).

use FindBin '$Bin';
use lib $Bin;
use GeminiConverse qw(new);

# ----------------------------------------------------------------------
# cmd_gemini_chat
#
# Launches an interactive chat session in the terminal.
# Arguments:
#   - $model: (Optional) The Gemini model to use. Defaults to $DEFAULT_MODEL.
#   - $system_prompt: (Optional) The initial persona/instruction. Defaults to $DEFAULT_SYSTEM.
# ----------------------------------------------------------------------
sub cmd_gemini_chat {
    my ($arg) = @_;

    # Use defaults if arguments are not provided
    my $model         = 'gemini-2.5-flash';
    my $system_prompt =
        'you are a Veteran C++ Architect (ISO/IEC 14882 expert). Your sole function is to review provided code diffs. Your review must be concise, direct, and actionable, adhering strictly to C++17 standards and best practices (RAII, smart pointers, constexpr). Focus on:
1. **Memory Safety:** Immediately flag any raw pointer use, manual memory management, or potential leaks.
2. **Performance:** Identify inefficient loops, excessive copying, or unnecessary dynamic allocation.
3. **Correctness:** Check for threading issues, race conditions, and undefined behavior.
4. **Design:** Ensure proper use of polymorphism, templates, and adherence to SOLID principles where applicable.
Suppress any introductory or conversational preambles. Get straight to the review points.';

    # 1. Pre-Check and Initialization
    unless ($ENV{GEMINI_API_KEY}) {
        print STDERR "FATAL: GEMINI_API_KEY environment variable not set.\n";
        return;
    }

    print "--- Starting Interactive Gemini Chat ---\n";
    print "Model: $model\n";
    print "Persona: '" . substr( $system_prompt, 0, 80 ) . "...'\n";
    print "Type /q or /e to end the conversation.\n\n";

    # Create the conversational session object (this holds the memory)
    my $chat = GeminiConverse->new(
        model  => $model,
        system => $system_prompt,
        );

    # 2. Main Chat Loop
    while (1) {
        # Prompt for user input
        print "gemini > ";

        # Read the line (strips the newline)
        my $user_input = <STDIN>;
        last unless defined $user_input; # Handle EOF (Ctrl+D)
        chomp $user_input;
        $user_input =~ s/^\s+|\s+$//g; # Trim whitespace

        # Check for exit commands
        if ($user_input =~ /^\/(q|e|\.)$/i) {
            print "\nSession closed. Goodbye!\n";
            last;
        }

        # Skip if input is empty after trimming
        next unless length $user_input;

        # 3. Get Reply and Handle Errors
        my $reply;
        eval {
            $reply = $chat->reply($user_input);
        };

        if ($@) {
            # Catch API or network errors
            print STDERR "\nü§ñ ERROR: An issue occurred during the API call.\n";
            print STDERR "Details: $@\n\n";
        } elsif (defined $reply) {
            # Print the model's response
            print "ü§ñ jim: $reply\n\n";
        } else {
            # Fallback for unexpected empty reply
            print "ü§ñ jim: (I received no response from the model.)\n\n";
        }
    }
}

sub cmd_grep_diffs {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: g <regexp>\n";
        return;
    }

    # Reset the grep set and index
    @grep_set = ();
    $current_grep_index = undef;

    # Get the sorted list of file names and search
    my @pr_files = sort keys %files_data;

    print "Searching diffs for **'$regexp'** in " . scalar(@pr_files) . " files...\n";

    for my $i (0 .. $#pr_files) {
        my $file_name = $pr_files[$i];
        my $file_index = $i + 1; # 1-based index

        # Retrieve the raw diff content for the file
        my ($diff, $err) = get_file_diff_content($file_name);

        # Skip if error
        next if $err;

        # Search only added (+) or removed (-) lines, ignoring context lines (space)
        my $match_found = 0;
        foreach my $line (split /\n/, $diff) {
            # Use '^[+-]' to target only changed lines in the diff
            if ($line =~ /^[+-]/ && $line =~ /$regexp/i) {
                $match_found = 1;
                last;
            }
        }

        if ($match_found) {
            # Store the **1-based file index**
            push @grep_set, $file_index;
            print sprintf("  [ %2d ]: %s\n", $file_index, $file_name);
        }
    }

    my $match_count = scalar(@grep_set);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp'.\n";
        # Select the first matching file and set the grep index
        $current_grep_index = 1;
        my $first_file_index = $grep_set[0];
        print "Selecting first matching file (Index $first_file_index).\n";

        # Select file and show diffs automatically
        cmd_select_file($first_file_index, 0);
    } else {
        print "No files found matching '$regexp' in diffs.\n";
    }
}

# --- Utility to navigate the grep set (used by g+ and g-) ---
sub _navigate_grep_set {
    my ($direction) = @_; # +1 for next, -1 for previous

    if (!@grep_set) {
        print "No previous 'g' command set. Use 'g <regexp>' first.\n";
        return;
    }

    # Ensure index is defined (should be 1 after 'g')
    if (!defined $current_grep_index) {
        $current_grep_index = 1;
    }

    my $new_grep_index = $current_grep_index + $direction;
    my $max_grep_index = scalar(@grep_set);

    if ($new_grep_index < 1) {
        print "Beginning of grep set reached (at file 1).\n";
        return;
    } elsif ($new_grep_index > $max_grep_index) {
        print "End of grep set reached (at file $max_grep_index).\n";
        return;
    }

    # Update state
    $current_grep_index = $new_grep_index;

    # Get the actual 1-based file index from the grep set array
    my $file_index_to_select = $grep_set[$current_grep_index - 1];

    print "Navigating to file **$current_grep_index/$max_grep_index** in grep set (File index $file_index_to_select).\n";

    # Select file and show diffs
    cmd_select_file($file_index_to_select, 0);
}

### `cmd_grep_diffs_next` (`g+`)
sub cmd_grep_diffs_next {
    _navigate_grep_set(1);
}

### `cmd_grep_diffs_prev` (`g-`)
sub cmd_grep_diffs_prev {
    _navigate_grep_set(-1);
}

sub cmd_grep_local {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: gl <regexp>\n";
        return;
    }

    # Reset the global grep set and index for navigation
    @grep_set = ();
    $current_grep_index = undef;

    # Assuming @pr_files contains the full list of file paths for the current PR
    my @pr_files_sorted = sort @pr_files;

    print "Branch: " . get_current_branch() . "\n";
    print "üîç Searching **local files** for pattern: **'$regexp'** in " . scalar(@pr_files_sorted) . " files...\n";

    # Iterate through the files tracked in the PR
    for my $i (0 .. $#pr_files_sorted) {
        my $file_name = $pr_files_sorted[$i];
        my $file_index = $i + 1; # 1-based index

        # Pure Perl File Reading with open handle
        unless (-f $file_name) {
            print STDERR "Skipping '$file_name': File not found locally.\n";
            next;
        }

        open my $fh, '<', $file_name or do {
            warn "Could not open '$file_name': $!\n";
            next;
        };

        my $match_found = 0;
        my $line_num = 0;

        # Search line by line
        while (my $line = <$fh>) {
            $line_num++;

            # Perform the case-sensitive regex match
            if ($line =~ /$regexp/i) {
                if (!$match_found) {
                    # Only print header once per file
                    print "\n-- **$file_name** (Index $file_index) --\n";
                }
                $match_found = 1;

                # Print the line number and the matching line content
                print sprintf("  %4d: %s", $line_num, $line);
            }
        }
        close $fh;

        if ($match_found) {
            # Store the **1-based file index** for g+/g- navigation
            push @grep_set, $file_index;
        }
    }

    my $match_count = scalar(@grep_set);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp'.\n";

        # ü§ù Integrate with g+ / g- navigation
        $current_grep_index = 1;
        my $first_file_index = $grep_set[0];
        print "Selecting first matching file (Index $first_file_index). Use 'g+'/'g-' to navigate.\n";

        # Select file and show diffs automatically (assuming cmd_select_file exists)
        cmd_select_file($first_file_index, 1);
    } else {
        print "No files found matching '$regexp' locally.\n";
    }
}

sub get_current_branch {
    # Check if we are in a Git repository
    if (-d ".git") {
        # Executes 'git rev-parse --abbrev-ref HEAD' to get the current branch name
        my $branch = `git rev-parse --abbrev-ref HEAD 2>/dev/null`;
        chomp $branch;
        return $branch;
    }
    return "NOT-IN-GIT";
}

sub cmd_history {
    print "Command History:\n";
    # Show the last 10 commands by default
    my $start = scalar(@command_history) > 10 ? scalar(@command_history) - 10 : 0;

    for my $i ($start .. $#command_history) {
        # Print 1-based index (i + 1) and the command
        printf "  %4d  %s\n", $i + 1, $command_history[$i];
    }
}

# --- NEW HISTORY PROCESSING FUNCTION ---
# Returns the final command string to be executed, or undef if only printing/error.
sub process_history_input {
    my ($input) = @_;

    # 1. Handle history expansion: !! or !N, optionally followed by :p
    if ($input =~ /^\s*(!\d*|!!)(:\S*)?\s*$/) {
        my $history_spec = $1; # e.g., '!!' or '!10'
        my $modifier = $2 || ''; # e.g., ':p'

        my $history_size = scalar(@command_history);
        my $history_index;

        # Determine the target index
        if ($history_spec eq '!!') {
            $history_index = $history_size; # Target is the last command
        } elsif ($history_spec =~ /^!(\d+)$/) {
            $history_index = $1; # Target is the explicit index
        }

        # Check for bounds (1-based index)
        if ($history_index < 1 || $history_index > $history_size) {
            print STDERR "History error: Event number $history_index not found.\n";
            return undef;
        }

        # Get the actual command string (0-based array access)
        my $resolved_command = $command_history[$history_index - 1];

        # Handle the ':p' modifier (Print only)
        if ($modifier eq ':p') {
            print ">> $resolved_command\n";
            return undef; # Do not execute
        }

        # Default: Execute the command
        print ">> $resolved_command\n";
        return $resolved_command;
    }

    # 2. Return the input as-is for normal commands or 'h'
    return $input;
}

sub cmd_select_file_name_regexp {
    my ($regexp) = @_;

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    if (!$regexp) {
        print "Usage: f <regexp> or fn <regexp>\n";
        return;
    }

    # Reset/initialize the list of matching files
    my @matched_files = ();

    # Assuming @pr_files is populated with the full list of file paths.
    # We must use the sorted list from cmd_list_files, which is implicit
    # if we rely on the 1-based index that 'lf' uses.
    my @pr_files_sorted = sort @pr_files;

    print "Searching file names for pattern: **'$regexp'**...\n";

    # Iterate through the files tracked in the PR
    for my $i (0 .. $#pr_files_sorted) {
        my $file_name = $pr_files_sorted[$i];
        my $file_index = $i + 1; # 1-based index

        # Perform the regex match on the file path
        # Using 'i' for case-insensitive matching by default (common for file names)
        if ($file_name =~ /$regexp/i) {
            # Store the 1-based index and the file name
            push @matched_files, {
                index => $file_index,
                name  => $file_name
            };
        }
    }

    my $match_count = scalar(@matched_files);

    if ($match_count > 0) {
        print "\nFound **$match_count** file(s) matching '$regexp':\n";

        # List all found files
        foreach my $match (@matched_files) {
            print sprintf(" %4d : %s\n", $match->{index}, $match->{name});
        }

        # Select the first matching file
        my $first_match = $matched_files[0];
        my $first_file_index = $first_match->{index};

        print "\nSelecting first matching file (Index $first_file_index).\n";

        # Select file and show diffs automatically (assuming cmd_select_file exists)
        # Note: $show_diffs=1 is the argument typically used to show diffs immediately.
        cmd_select_file($first_file_index, 1);

    } else {
        print "No files found matching '$regexp' in the PR file list.\n";
    }
}

# --- New Utility for History File Path ---
# Stores history in a dotfile in the current working directory for simplicity.
# This makes the history context-specific to where ghr is run (e.g., inside a repo).
sub get_history_file_path {
    return abs_path('.') . "/.ghr_command_history";
}

# --- Load History from File ---
sub load_history {
    my $history_file = get_history_file_path();

    if (-f $history_file) {
        open my $fh, '<', $history_file or do {
            warn "Warning: Could not open history file for reading: $!\n";
            return;
        };

        # Read history line by line
        my @loaded_history;
        while (my $line = <$fh>) {
            chomp $line;
            push @loaded_history, $line;
        }
        close $fh;

        # Replace the global array, respecting the max size
        # $history_max_size is defined in your global state (default 100)
        @command_history = @loaded_history;
        while (scalar(@command_history) > $history_max_size) {
            shift @command_history;
        }

        print "Loaded " . scalar(@command_history) . " commands from history.\n";
    }
}

# --- Save History to File ---
sub save_history {
    my $history_file = get_history_file_path();

    # Save only the history that fits within the configured maximum size
    my @history_to_save = @command_history;
    while (scalar(@history_to_save) > $history_max_size) {
        shift @history_to_save;
    }

    open my $fh, '>', $history_file or do {
        warn "Warning: Could not open history file for writing: $!\n";
        return;
    };

    # Write each command on a new line
    foreach my $command (@history_to_save) {
        print $fh "$command\n";
    }
    close $fh;

    print "Saved " . scalar(@history_to_save) . " commands to history file.\n";
}
