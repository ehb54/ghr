#!/usr/bin/env perl
use strict;
use warnings;
use Cwd 'abs_path';
use JSON 'decode_json', 'encode_json';
# File::Slurp, Term::ReadLine::Gnu or similar would be needed for a richer experience,
# but for basic CLI in emacs shell, standard IO is fine.

# --- Global State ---
my $current_pr = undef;
my $current_file_index = undef; # 1-based index from 'lf'
my $current_file_name = undef; # Actual file path
my @pr_files = (); # Array of file names for the current PR
my %comments = (
    'global' => [], # Array of global comments: {text => ..., status => 'local'|'pushed'}
    'files' => {}, # Hash: 'path/to/file.txt' => [ {line => ..., pos => ..., text => ..., status => 'local'|'pushed'}, ... ]
    'review_state' => undef # 'approve' | 'request_changes'
);
my %files_data;

# --- Command Dispatch Table ---
# Maps user input to the corresponding subroutine
my %COMMANDS = (
    'q'       => \&cmd_quit,
    'h'       => \&cmd_help,
    'lpr'     => \&cmd_list_prs,
    'lc'      => \&cmd_load_comments,
    'lgc'     => \&cmd_load_general_comments,
    'pr'      => \&cmd_select_pr,
    'lf'      => \&cmd_list_files,
    'sf'      => \&cmd_select_file,
    '+'       => \&cmd_select_file,
    '-'       => \&cmd_select_file,
    'sd'      => \&cmd_show_diffs,
    'sdiw'    => \&cmd_show_diffs_ignore_whitespace,
    'so'      => \&cmd_show_original,
    'sn'      => \&cmd_show_new,
    'ca'      => \&cmd_add_comment,
    'cd'      => \&cmd_delete_comment,
    'cp'      => \&cmd_push_comments,
    'rs'      => \&cmd_review_summary,
    'accept'  => \&cmd_accept_review,
    'reject'  => \&cmd_reject_review,
);

# --- GH CLI Check ---
sub check_gh_auth {
    # Check if 'gh' is installed and authenticated by running a simple command
    my $output = `gh auth status 2>&1`;
    if ($? != 0 || $output =~ /not logged into any GitHub hosts/) {
        die "Error: 'gh' command failed or you are not logged in.\nPlease run 'gh auth login'.\n";
    }
    print "GitHub CLI is authenticated.\n";
}
check_gh_auth();

# --- Main Logic ---
sub get_prompt {
    my $prompt = "ghr";

    if (defined $current_pr) {
        $prompt .= " [$current_pr]";

        # --- Add File Index and Total Count ---
        if (defined $current_file_name) {
            # 1. Get total count
            my $total_files = scalar(keys %files_data);

            # 2. Get current index (guaranteed to be defined if $current_file_name is defined)
            my $current_index = $current_file_index // 0;

            # Format the prompt segment: [1/100] filename
            $prompt .= " [$current_index/$total_files] $current_file_name";
        }
    }

    $prompt .= " > ";
    return $prompt;
}

sub main {
    while (1) {
        # Print the dynamic prompt
        print get_prompt();

        # Read line (Control-D/EOF will result in undef)
        my $input = <STDIN>;
        last unless defined $input; # Exit on EOF (Ctrl-D)

        chomp $input;
        next unless length $input; # Skip empty lines

        # Split into command and arguments
        my @parts = split /\s+/, $input, 2;
        my $cmd = lc $parts[0];
        my $args = $parts[1] // '';

        # --- NON-BREAKING FIX: If command is '+' or '-', set $args to the command itself ---
        if (($cmd eq '+' || $cmd eq '-') && $args eq '') {
            $args = $cmd;
        }

        # Dispatch the command
        if (my $sub = $COMMANDS{$cmd}) {
            eval {
                $sub->($args);
            };
            if ($@) {
                print "Command Error: $@\n";
            }
        } else {
            print "Unknown command: '$cmd'. Type 'h' for help.\n";
        }
    }
    print "\nExiting.\n";
}

main(); # Start the program

# --- Command Implementations ---

sub cmd_quit {
    my $unpushed_count = get_unpushed_comment_count();
    if ($unpushed_count > 0) {
        print "Warning: You have $unpushed_count unpushed local comments.\n";
        print "Are you sure you want to quit without pushing? (y/N): ";
        my $confirm = <STDIN>;
        return unless $confirm =~ /^[yY]/;
    }
    exit 0;
}

sub cmd_help {
    print <<'HELP_TEXT';
## GitHub Review CLI (ghr) Help

q         // quit (or control-D/EOF)
h         // print this help
lpr       // list PRs (Uses 'gh pr list')
pr PR#    // select PR (e.g., 'pr 123')
lf        // list files in the current PR
lc        // list pushed comments in the current PR
lgc       // list global comments in the current PR
sf file#  // select file by number, or use '+' or '-' for next/previous
+         // select next file and show diffs
sd        // show diffs for selected file
so        // show original lines for selected file (with line numbers)
sn        // show new lines for selected file (with positional info)
ca pos    // add comment. 'pos' is position # from 'sn', or 'g' for global.
cd pos    // delete comment by position # or 'g' for global.
cp        // pushes all local comments to GitHub (asks confirmation)
rs        // review summary (all local and pushed comments)
accept    // accept PR (asks confirmation, pushes comments)
reject    // reject PR (asks confirmation, pushes comments)

HELP_TEXT
}

sub cmd_list_prs {
    print "Fetching list of open pull requests...\n";
    # Simple call, Emacs shell handles pagination
    system('gh pr list --state open --limit 50');
}

sub cmd_select_pr {
    my ($pr_num) = @_;
    if ($pr_num =~ /^\d+$/) {
        # Check if PR is valid and get file list
        my $file_list_json = `gh pr view $pr_num --json files 2>/dev/null`;
        if ($? != 0) {
            print "Error: PR #$pr_num not found or inaccessible.\n";
            return;
        }

        # Clear existing state and comments
        $current_pr = $pr_num;
        $current_file_index = undef;
        $current_file_name = undef;
        %comments = (
            'global' => [],
            'files' => {},
            'review_state' => undef
        );

        my $data = decode_json($file_list_json);
        @pr_files = map { $_->{path} } @{$data->{files}};

        # --- POPULATE %files_data ---
        # Iterate through the returned file paths and populate the global hash.
        # The value can be a placeholder (like 1) or a hash of metadata if needed later.
        my $file_count = 0;
        foreach my $file_path (@pr_files) {
            chomp $file_path;
            
            # Trim surrounding quotes if gh/jq added them
            $file_path =~ s/^"|"$//g; 
            
            # Store the file path as a key in the global hash
            $files_data{$file_path} = 1; # Storing 1 as a placeholder status
            $file_count++;
        }

        # Add existing comments for a richer experience (optional but good)
        # my $existing_comments = `gh pr review $pr_num --json comments`;
        # ... logic to parse and load existing comments ...

        print "Selected PR #$current_pr with " . scalar(@pr_files) . " files.\n";

    } else {
        print "Usage: pr <PR#>\n";
    }
}

sub cmd_list_files {
    if (!defined $current_pr) {
        print "No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }
    print "Files in PR #$current_pr:\n";
    for my $i (0 .. $#pr_files) {
        my $status = defined $comments{files}{$pr_files[$i]} ? "(C)" : ""; # Commented
        print sprintf(" %2d: %s %s\n", $i + 1, $pr_files[$i], $status);
    }
}

# --- Utility Functions (Place after commands) ---

sub get_unpushed_comment_count {
    my $count = scalar grep { $_->{status} eq 'local' } @{$comments{global}};
    for my $file (keys %{$comments{files}}) {
        $count += scalar grep { $_->{status} eq 'local' } @{$comments{files}{$file}};
    }
    return $count;
}

sub cmd_select_file {
    my ($arg) = @_; # $arg is now correctly '+', '-', a number, or ''

    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    # IMPORTANT: Use the global file list variable
    # NOTE: @pr_files must be populated in cmd_select_pr()
    my @pr_files = sort keys %files_data;
    my $max_index = scalar(@pr_files);

    my $new_index;
    my $is_nav_command = 0; # Flag to determine if a diff should be shown

    # 1. Check for '+'
    if ($arg eq '+') {
        # If no file is selected yet, start from index 1 (the first file)
        $new_index = (defined $current_file_index) ? $current_file_index + 1 : 1;
        if ($new_index > $max_index) {
            print "End of file list reached (at file $max_index).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 2. Check for '-'
    elsif ($arg eq '-') {
        # If no file is selected, cannot go backward
        if (!defined $current_file_index) {
            print "No file currently selected. Cannot move backward.\n";
            return;
        }
        $new_index = $current_file_index - 1;
        if ($new_index < 1) {
            print "Beginning of file list reached (at file 1).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 3. Check for file number
    elsif ($arg =~ /^\d+$/) {
        $new_index = $arg;
        if ($new_index < 1 || $new_index > $max_index) {
            print "Error: File number $arg is out of range (1-$max_index).\n";
            return;
        }
        $is_nav_command = 1;
    }
    # 4. Handle Usage (This is only hit when user types 'sf' with no argument, $arg is '')
    elsif ($arg eq '') {
        print "Usage: sf <file#> | + | -\n";
        return;
    }
    else {
        # Catch all for unrecognized arguments like 'sf abc'
        print "Unrecognized argument for file selection: '$arg'.\n";
        return;
    }

    # --- Update state ---
    $current_file_index = $new_index;
    $current_file_name = $pr_files[$current_file_index - 1]; # Convert 1-based index to 0-based array index

    print "Selected file **$current_file_name** ($current_file_index/$max_index).\n";

    # Display any existing comments for the file (your existing logic)
    if (exists $comments{files}{$current_file_name} && @{$comments{files}{$current_file_name}}) {
        # ... (comment printing logic) ...
        print "\nLocal/Pushed comments for this file:\n";
        foreach my $c (@{$comments{files}{$current_file_name}}) {
            my $status = ($c->{status} eq 'local') ? '[LOCAL]' : '[PUSHED]';
            print "  $status Pos: $c->{pos}, Line: $c->{line} -> \"$c->{text}\"\n";
        }
        print "\n";
    }

    # --- Run 'sd' automatically for navigation commands ---
    # This runs the diff for '+', '-', and 'sf #' commands
    if ($is_nav_command) {
        cmd_show_diffs();
    }
}

# --- Utility: Retrieve the raw diff for a specific or current file (REFACTORED) ---
# Argument: Optional file name string
sub get_file_diff_content {
    my ($file_name_override) = @_;
    
    my $target_file = $file_name_override || $current_file_name;

    if (!defined $current_pr || !defined $target_file) {
        return undef, "Error: No PR or file selected.\n";
    }

    # 1. Fetch the full diff for the PR (runs only once per command execution)
    my $cmd = "gh pr diff $current_pr 2>&1";
    my $full_diff = `$cmd`;

    if ($? != 0) {
        return undef, "Error running 'gh pr diff': $full_diff\n";
    }

    # 2. Use a regex match to find the start and stop of the file section
    my $escaped_file_name = quotemeta($target_file);
    
    # This regex captures the content for $target_file
    if ($full_diff =~ /(diff --git a\/$escaped_file_name.*?)(\ndiff --git a\/|\z)/s) {
        my $file_diff = $1;
        return $file_diff, "";
    }
    
    # Fallback/Error case
    return undef, "Error: Could not find diff section for file **$target_file** in PR #$current_pr.\n";
}

sub cmd_show_diffs {
    # Call without argument uses $current_file_name
    my ($diff, $err) = get_file_diff_content(); 
    if ($err) { print $err; return; }
    print "$diff\n";
}

sub cmd_show_original {
    my ($diff, $err) = get_file_diff_content();
    if ($err) {
        print $err;
        return;
    }

    my ($original_line, $new_line) = (0, 0);
    my $is_new_file = 0; # Flag to check if the file is new

    print "\n--- Original Changed Lines in $current_file_name ---\n";

    foreach my $line (split /\n/, $diff) {
        # Check for 'new file mode' to confirm it's a new file (optional, but good)
        if ($line =~ /^new file mode/) {
            $is_new_file = 1;
        }

        # Hunk header: @@ -<Original_Start>,<Original_Count> +<New_Start>,<New_Count> @@
        if ($line =~ /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/) {
            $original_line = $1;
            $new_line = $2;
            
            if ($original_line == 0) {
                print "\n-- Hunk starts (New File: No original lines to show) --\n";
                # If original line starts at 0, it's a new file (or an empty file start)
                next; 
            }
            
            print "\n-- Hunk starts (Original Line $original_line) --\n";
            next;
        }

        # Skip non-hunk-related lines that aren't content (like header lines)
        next if $line !~ /^[ \-+\\]/;

        # Context line: start with ' '
        if ($line =~ /^\s/) {
            $original_line++;
            $new_line++;
            next;
        }

        # Original (Removed) line: starts with '-'
        elsif ($line =~ /^-/) {
            # Only print if this is NOT a new file (i.e., if it's a removal or modification)
            if (!$is_new_file) {
                print sprintf("%4d: %s\n", $original_line, substr($line, 1));
            }
            $original_line++;
            next;
        }

        # New (Added) line: starts with '+'
        elsif ($line =~ /^\+/) {
            $new_line++;
            next;
        }
    }
    
    if ($is_new_file) {
        print "\nFile **$current_file_name** is a new file. No 'Original' lines exist.\n";
    }
}

sub cmd_show_new {
    my ($diff, $err) = get_file_diff_content();
    if ($err) {
        print $err;
        return;
    }

    my ($new_line, $position) = (0, 0);
    my $is_removed_file = 0; # Flag to check if the file is removed

    print "\n--- New Changed Lines in $current_file_name (for 'ca' command) ---\n";

    foreach my $line (split /\n/, $diff) {
        # Check for 'deleted file mode'
        if ($line =~ /^deleted file mode/) {
            $is_removed_file = 1;
        }

        # Hunk header: Reset counters
        if ($line =~ /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/) {
            $new_line = $2;
            $position = 0; # Position is relative to the start of the current hunk
            
            if ($new_line == 0) {
                print "\n-- Hunk starts (Removed File: No new lines to comment) --\n";
                next;
            }
            
            print "\n-- Hunk starts (New Line $new_line) --\n";
            next;
        }

        # Skip non-hunk-related lines that aren't content (like header lines)
        next if $line !~ /^[ \-+\\]/;

        # Context line: start with ' '
        if ($line =~ /^\s/) {
            $new_line++;
            $position++;
            # For context lines, print only for reference, not for commenting
            print sprintf("%4s:%4d: %s\n", '', $new_line, substr($line, 1));
            next;
        }

        # Original (Removed) line: starts with '-'
        elsif ($line =~ /^-/) {
            # Removed lines *do* increment position, but cannot be commented on directly
            $position++;
            # For removed lines, print only for reference
            print sprintf("%4s:%4s: %s\n", '', '-', substr($line, 1));
            next;
        }

        # New (Added) line: starts with '+'
        elsif ($line =~ /^\+/) {
            # Only + lines get comment positions
            print sprintf("%4d:%4d: %s\n", $position, $new_line, substr($line, 1));
            $new_line++;
            $position++;
            next;
        }
    }
    
    if ($is_removed_file) {
        print "\nFile **$current_file_name** is a removed file. Comments can only be added to lines that still exist.\n";
    } else {
        print "\nNote: Use the **first column number** (Position #) with 'ca' command.\n";
    }
}

use Data::Dumper; # Useful for debugging the data structure

sub cmd_add_comment {
    my ($args) = @_;
    my ($pos, $initial_text) = split /\s+/, $args, 2;
    $pos = lc $pos;
    
    # 1. Input Validation and Target Determination
    if (!defined $pos || ($pos ne 'g' && $pos !~ /^\d+$/)) {
        print "Usage: ca <position # | g> [initial comment text]\n";
        print "  'g' is for a global review comment.\n";
        print "  Position # is found via the 'sn' command.\n";
        return;
    }

    my $target_type;
    my $target_key;
    my $line_num_for_push = undef; # The actual line number, needed for the gh comments.json

    if ($pos eq 'g') {
        $target_type = 'global';
        $target_key = 'global';
        print "Adding a GLOBAL comment. Type your comment, terminate with a '.' on a single line:\n";
    } else {
        # Positional Comment Check
        if (!defined $current_file_name) {
            print "Error: Cannot add positional comment. No file selected. Use 'sf' first.\n";
            return;
        }
        $target_type = 'positional';
        $target_key = $current_file_name;
        
        # We need to find the corresponding actual line number ($new_line) for the given $pos
        # This requires re-running the 'sn' logic, but just to map pos -> line
        ($line_num_for_push, my $valid) = _map_pos_to_line($pos, $current_file_name);
        if (!$valid) {
            print "Error: Position #$pos is invalid for file **$current_file_name**. Use 'sn' to see valid positions.\n";
            return;
        }

        print "Adding comment at position **$pos** (Line $line_num_for_push) in **$current_file_name**.\n";
        print "Type your comment, terminate with a '.' on a single line:\n";
    }

    # 2. Collect Multiline Input
    my $comment_text = defined $initial_text ? $initial_text : "";
    
    # If there was an initial text, add a newline before starting multiline input
    $comment_text .= "\n" if $comment_text ne ""; 

    while (<STDIN>) {
        chomp;
        last if $_ eq '.';
        $comment_text .= "$_\n";
    }

    # 3. Store the Comment
    my $new_comment = {
        text   => $comment_text,
        status => 'local', # Always starts as local
        pos    => $pos,    # 'g' or position number
        # Only set file-specific data for positional comments
        ($target_type eq 'positional' ? (
            file => $current_file_name,
            line => $line_num_for_push
        ) : ())
    };

    # Ensure the file entry exists in %comments
    if ($target_type eq 'positional' && !exists $comments{files}{$target_key}) {
        $comments{files}{$target_key} = [];
    }

    # Push the new comment into the data structure
    my $storage = ($target_type eq 'global') ? $comments{global} : $comments{files}{$target_key};
    push @$storage, $new_comment;

    print "\nComment added successfully (local: $target_type, pos: $pos).\n";
}

# --- Utility to map position to line number (CORRECTED) ---
# This is crucial for building the 'gh pr review --comments' JSON later.
sub _map_pos_to_line {
    my ($target_pos, $file_name) = @_;
    
    # Pass the required $file_name to the refactored utility
    my ($diff, $err) = get_file_diff_content($file_name);
    return undef, 0 if $err; 

    my ($new_line, $position) = (0, 0);

    # ... (The rest of the parsing logic remains identical to the previous implementation) ...
    
    foreach my $line (split /\n/, $diff) {
        if ($line =~ /^@@ .* \+(\d+)(?:,\d+)? @@/) {
            $new_line = $1;
            $position = 0;
            next;
        }

        if ($line =~ /^\s/ || $line =~ /^-/) {
            $position++;
            $new_line++ if $line =~ /^\s/;
            next;
        }
        
        if ($line =~ /^\+/) {
            if ($position eq $target_pos) {
                return $new_line, 1; 
            }
            $new_line++;
            $position++;
            next;
        }
    }
    
    return undef, 0; 
}

sub cmd_delete_comment {
    my ($pos) = @_;
    $pos = lc $pos;

    # 1. Input Validation and Target Determination
    if (!defined $pos || ($pos ne 'g' && $pos !~ /^\d+$/)) {
        print "Usage: cd <comment_index | g>\n";
        print "  'g' deletes a GLOBAL comment (requires index).\n";
        print "  Comment index is found by listing comments (e.g., using 'rs' or 'sf').\n";
        return;
    }
    
    my $target_type;
    my $comment_storage;

    if ($pos eq 'g') {
        $target_type = 'global';
        $comment_storage = $comments{global};
        print "Existing GLOBAL comments:\n";
    } else {
        if (!defined $current_file_name) {
            print "Error: Cannot delete positional comment. No file selected. Use 'sf' first.\n";
            return;
        }
        $target_type = 'positional';
        $comment_storage = $comments{files}{$current_file_name} // [];
        print "Existing comments in **$current_file_name**:\n";
    }
    
    if (!@$comment_storage) {
        print "No $target_type comments exist to delete.\n";
        return;
    }

    # 2. List Comments and Get Index
    # Use a loop to list the comments with an index for deletion
    my @indices_to_delete;
    for my $i (0 .. $#$comment_storage) {
        my $c = $comment_storage->[$i];
        my $status = ($c->{status} eq 'local') ? '[L]' : '[P]';
        my $info = ($target_type eq 'positional') ? "Pos: $c->{pos}, Line: $c->{line}" : "";
        print sprintf(" [%2d] %s %s: %s\n", $i + 1, $status, $info, substr($c->{text}, 0, 50) . '...');
    }
    
    print "\nEnter the **index number** (1 to " . scalar(@$comment_storage) . ") to delete, or 'a' for all, or 'c' to cancel: ";
    my $delete_input = <STDIN>;
    chomp $delete_input;

    if ($delete_input =~ /^\d+$/) {
        my $idx = $delete_input - 1; # Convert 1-based to 0-based
        if ($idx >= 0 && $idx <= $#$comment_storage) {
            push @indices_to_delete, $idx;
        } else {
            print "Error: Invalid index.\n";
            return;
        }
    } elsif (lc $delete_input eq 'a') {
        @indices_to_delete = (0 .. $#$comment_storage);
    } else {
        print "Deletion cancelled.\n";
        return;
    }

    # 3. Perform Deletion (in reverse order to preserve indices)
    @indices_to_delete = sort {$b <=> $a} @indices_to_delete; # Sort descending
    
    my $deleted_count = 0;
    foreach my $idx (@indices_to_delete) {
        splice(@$comment_storage, $idx, 1);
        $deleted_count++;
    }

    # Clean up file entry if all comments were removed
    if ($target_type ne 'global' && !@$comment_storage) {
        delete $comments{files}{$current_file_name};
    }
    
    print "Successfully deleted $deleted_count $target_type comment(s).\n";
}

sub cmd_review_summary {
    print "\n======================================================\n";
    print "### üìã REVIEW SUMMARY for PR #$current_pr ###\n";
    print "======================================================\n";

    # --- 1. Review Status ---
    my $review_state = $comments{review_state} // 'PENDING';
    print "Review Status: **$review_state**\n";
    print "------------------------------------------------------\n";

    # --- 2. Global Comments ---
    my @global_comments = @{$comments{global}};
    if (@global_comments) {
        print "### üåé Global Comments: (" . scalar(@global_comments) . ") ###\n";
        
        my $local_count = 0;
        my $pushed_count = 0;
        
        for my $i (0 .. $#global_comments) {
            my $c = $global_comments[$i];
            my $status = $c->{status};
            
            if ($status eq 'local') {
                $local_count++;
            } else {
                $pushed_count++;
            }
            
            # Use index + 1 for user readability when referencing with 'cd g'
            print sprintf(" [%2d] %s: %s\n", $i + 1, uc($status), $c->{text});
        }
        
        print "  -> Summary: **$local_count Local**, **$pushed_count Pushed**\n";
        print "------------------------------------------------------\n";
    } else {
        print "### üåé Global Comments: None ###\n";
        print "------------------------------------------------------\n";
    }

    # --- 3. File Positional Comments ---
    my @commented_files = sort keys %{$comments{files}};
    
    if (@commented_files) {
        print "### üìÇ File Positional Comments: (" . scalar(@commented_files) . " files) ###\n";
        
        my $total_local_count = 0;
        my $total_pushed_count = 0;

        foreach my $file_name (@commented_files) {
            my @file_comments = @{$comments{files}{$file_name}};
            next unless @file_comments;
            
            print "\nFile: **$file_name** (" . scalar(@file_comments) . " comments)\n";

            my $file_local_count = 0;
            my $file_pushed_count = 0;
            
            for my $i (0 .. $#file_comments) {
                my $c = $file_comments[$i];
                my $status = $c->{status};
                
                if ($status eq 'local') {
                    $file_local_count++;
                } else {
                    $file_pushed_count++;
                }

                # Use index + 1 for user readability when referencing with 'cd'
                print sprintf(" [%2d] %s (Pos: %-4s | Line: %-4s) %s\n", 
                    $i + 1, uc($status), $c->{pos}, $c->{line}, $c->{text});
            }
            
            $total_local_count += $file_local_count;
            $total_pushed_count += $file_pushed_count;
        }

        print "\n--- TOTAL POSITIONAL SUMMARY ---\n";
        print "  -> **$total_local_count Local** comments across " . scalar(@commented_files) . " files.\n";
        print "  -> **$total_pushed_count Pushed** comments.\n";
        print "------------------------------------------------------\n";
    } else {
        print "### üìÇ File Positional Comments: None ###\n";
        print "------------------------------------------------------\n";
    }
}

use JSON 'encode_json';
use File::Temp 'tempfile';

# Utility: Builds the comments.json file required by 'gh pr review'
# Returns: The path to the temporary JSON file, or undef on error.
sub build_comments_json {
    my @gh_comments = ();

    # Iterate through all files that have comments
    foreach my $file_name (keys %{$comments{files}}) {
        my @file_comments = @{$comments{files}{$file_name}};
        
        # Filter for only local, unpushed comments
        foreach my $c (@file_comments) {
            next unless $c->{status} eq 'local';
            
            # The 'gh pr review' API requires the following structure:
            # - path: The file path
            # - position: The position offset from the start of the hunk (found via 'sn')
            # - body: The comment text
            push @gh_comments, {
                path     => $c->{file},
                position => $c->{pos},
                body     => $c->{text},
                # NOTE: line is not strictly required if position is provided,
                # but including the line number can sometimes improve reliability.
                line     => $c->{line}
            };
        }
    }

    # If no positional comments are local, return undef (no file needed)
    return undef unless @gh_comments;

    # Create a temporary file to hold the JSON data
    my ($fh, $filename) = tempfile(
        "ghr_comments_XXXXXX", 
        DIR => "/tmp", # Use /tmp or a dedicated directory
        UNLINK => 1   # Important: Unlink immediately so it's deleted when the file handle closes
    );
    
    # Write the JSON data to the file
    my $json_data = encode_json(\@gh_comments);
    print $fh $json_data;
    close $fh;
    
    print "Created temporary comments JSON file: $filename\n";
    return $filename;
}

# Utility: Updates the status of all local comments to 'pushed'
sub _mark_local_comments_as_pushed {
    # Mark global comments
    for my $c (@{$comments{global}}) {
        $c->{status} = 'pushed' if $c->{status} eq 'local';
    }

    # Mark positional comments
    foreach my $file_name (keys %{$comments{files}}) {
        for my $c (@{$comments{files}{$file_name}}) {
            $c->{status} = 'pushed' if $c->{status} eq 'local';
        }
    }
}

# Utility: Builds a single file containing both the global review body and 
#          the positional comments in the format required by 'gh pr review'.
# Returns: The path to the temporary body file, or undef if no comments/status to push.
sub _prepare_unified_body_file {
    my ($review_type) = @_; # 'comment', 'approve', or 'request_changes'
    
    my @global_local_comments = grep { $_->{status} eq 'local' } @{$comments{global}};
    my $has_local_positional = get_unpushed_comment_count() > scalar(@global_local_comments);
    
    # If no local comments and no explicit approval/rejection, nothing to push
    unless (scalar(@global_local_comments) > 0 || $has_local_positional || $review_type ne 'comment') {
        return undef;
    }
    
    # --- 1. Build the Review Body (Global Comments) ---
    my $review_body = "";
    if (@global_local_comments) {
        $review_body = join("\n---\n", map { "GLOBAL COMMENT:\n" . $_->{text} } @global_local_comments);
    } elsif ($review_type ne 'comment') {
        # If we are accepting/rejecting, provide a default minimal body if no global comments exist
        $review_body = "Review submitted via interactive CLI.";
    }

    # --- 2. Build the Positional Comments Section ---
    my $comments_section = "";
    if ($has_local_positional) {
        $comments_section .= "\n\n## Comments\n";
        
        # Iterate through all files that have local comments
        foreach my $file_name (keys %{$comments{files}}) {
            my @file_comments = @{$comments{files}{$file_name}};
            
            # Filter for only local, unpushed comments
            foreach my $c (grep { $_->{status} eq 'local' } @file_comments) {
                # gh pr review positional comments require line or position. We use line (safer).
                # The format uses YAML list syntax.
                $comments_section .= sprintf("- path: %s\n", $c->{file});
                $comments_section .= sprintf("  line: %s\n", $c->{line}); 
                $comments_section .= sprintf("  body: %s\n", $c->{text});
            }
        }
    }
    
    # --- 3. Create the Temporary File ---
    my ($fh, $temp_file) = tempfile("ghr_unified_XXXXXX", DIR => "/tmp", UNLINK => 1);
    print $fh $review_body;
    print $fh $comments_section;
    close $fh;
    
    return $temp_file;
}

sub cmd_push_comments {
    my $unpushed_count = get_unpushed_comment_count();

    if ($unpushed_count == 0) {
        print "No new local comments to push for PR #$current_pr.\n";
        return;
    }
    
    print "\nYou have **$unpushed_count** local comments (global and positional).\n";
    print "Are you sure you want to push these comments to GitHub now? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    return unless $confirm =~ /^[yY]/;
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file('comment'); # Pass 'comment' review type
    
    unless (defined $temp_file) {
        print "Error: Failed to create unified comment body file.\n";
        return;
    }
    
    # --- 2. Execute Command (gh pr review) ---
    # The combination of '--comment' and '--body-file' is the correct syntax
    # for a comment-only submission without changing the review status.
    my @cmd_parts = ("gh", "pr", "review", $current_pr, "--comment", "--body-file", $temp_file);

    print "\nPushing comments via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully pushed all $unpushed_count comment(s) to PR #$current_pr.\n";
        _mark_local_comments_as_pushed();
    } else {
        print "\n‚ùå Error pushing comments. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

sub cmd_accept_review {
    return unless defined $current_pr;
    $comments{review_state} = 'APPROVE';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting an **APPROVAL** of PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('approve');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Approval submission cancelled.\n";
    }
}

sub cmd_reject_review {
    return unless defined $current_pr;
    $comments{review_state} = 'REQUEST_CHANGES';
    
    cmd_review_summary(); # Show current status and comments
    
    print "\n======================================================\n";
    print "CONFIRM: You are submitting a **REQUEST FOR CHANGES** on PR #$current_pr.\n";
    print "This will push all local comments and finalize the review.\n";
    print "Are you sure you want to proceed? (y/N): ";
    my $confirm = <STDIN>;
    chomp $confirm;

    if ($confirm =~ /^[yY]/) {
        _submit_review('request_changes');
    } else {
        $comments{review_state} = 'PENDING'; # Revert state if cancelled
        print "Rejection submission cancelled.\n";
    }
}

sub _submit_review {
    my ($review_type) = @_; # 'approve' or 'request_changes'
    
    my $temp_file = undef; 
    
    # --- 1. Prepare Unified Command Body ---
    $temp_file = _prepare_unified_body_file($review_type);

    # If no comments and no body file, we still submit the state, but gh may fail without a body file.
    # To be safe, we always generate a body file, even if minimal.
    unless (defined $temp_file) {
        # Fallback: Create a minimal body file if _prepare_unified_body_file returned undef
        my $default_body = $review_type eq 'approve' ? "Approved." : "Changes requested.";
        my ($fh, $filename) = tempfile("ghr_minimal_XXXXXX", DIR => "/tmp", UNLINK => 1);
        print $fh $default_body;
        close $fh;
        $temp_file = $filename;
    }

    # --- 2. Execute Command ---
    my $flag = ($review_type eq 'approve') ? '--approve' : '--request-changes';
    
    my @cmd_parts = ("gh", "pr", "review", $current_pr, $flag, "--body-file", $temp_file);
    
    print "\nSubmitting review via GitHub CLI...\n";
    my $final_cmd = join(" ", map { s/ /\\ /g; $_ } @cmd_parts);
    print "Executing: $final_cmd\n";
    
    my $output = system(@cmd_parts);

    # --- 3. Check Status and Cleanup ---
    if ($output == 0) {
        print "\n‚úÖ Successfully submitted review as " . uc($review_type) . " for PR #$current_pr.\n";
        # Mark all local comments as pushed
        _mark_local_comments_as_pushed();
        $comments{review_state} = uc($review_type);
    } else {
        # Revert state on failure
        $comments{review_state} = 'PENDING';
        print "\n‚ùå Error submitting review. Check gh CLI output above. Error code: $output\n";
    }
    
    if (defined $temp_file && -e $temp_file) {
        unlink $temp_file;
    }
}

use JSON 'decode_json'; 

sub cmd_load_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching submitted review comments for PR #$current_pr...\n";

    # --- 1. Get the repository path (owner/repo) using GH context variables ---
    # This path resolves the current repository context using {owner} and {repo}.
    my $repo_path_cmd = "gh api repos/{owner}/{repo} --jq '.full_name' 2>/dev/null";

    # For debugging: print "cmd: $repo_path_cmd\n"; 

    my $repo_path = `$repo_path_cmd`;
    chomp $repo_path;

    # Check the result. It should now return "ehb54/ultrascan3"
    if ($? != 0 || !$repo_path || $repo_path !~ /\//) {
        print "Error: Failed to determine repository path (owner/repo) using 'gh api'. Check your current directory and authentication.\n";
        return;
    }
    
    # Clean up any potential surrounding quotes from the jq output
    $repo_path =~ s/^"|"$//g;
    
    # --- 2. API Call to Fetch Positional Comments ---
    # Use the retrieved $repo_path to call the GitHub REST API.
    my $api_cmd = "gh api repos/$repo_path/pulls/$current_pr/comments --jq '
        .[] | {
            user: .user.login,
            body: .body,
            path: .path,
            line: .line,
            position: .position,
            created_at: .created_at
        }'";

    my $json_output = `$api_cmd`;
    
    if ($? != 0) {
        print "Error: Failed to fetch comments via gh api. Check permissions and 'gh auth status'.\n";
        return;
    }

    # --- 3. Parse and Display (Logic remains the same) ---
    my @comments_data = ();
    
    # gh api + jq returns a stream of JSON objects; split by newline and parse each
    foreach my $json_line (split /\n/, $json_output) {
        next unless $json_line =~ /^{/;
        eval {
            push @comments_data, decode_json($json_line);
        };
        if ($@) {
            print "Warning: Failed to parse comment JSON: $@\n";
        }
    }

    if (!@comments_data) {
        print "No submitted positional review comments found for PR #$current_pr.\n";
        return;
    }
    
    # Sort by file path and then line number for clean display
    @comments_data = sort { 
        $a->{path} cmp $b->{path} || $a->{line} <=> $b->{line} 
    } @comments_data;

    print "\n### üí¨ Submitted Comments by Other Reviewers ###\n";
    print "------------------------------------------------------\n";

    my $current_path = "";
    foreach my $c (@comments_data) {
        if ($c->{path} ne $current_path) {
            $current_path = $c->{path};
            print "\nFile: **$current_path**\n";
        }

        my $date_str = substr($c->{created_at}, 0, 10);
        
        print sprintf(" %-15s (Line: %-4s | Pos: %-4s) [%s]\n", 
            $c->{user}, $c->{line}, $c->{position}, $date_str
        );
        # Use simple indentation for the body
        my $body_preview = (split /\n/, $c->{body})[0];
        print "    > $body_preview...\n";
    }
    print "------------------------------------------------------\n";
}

sub cmd_load_general_comments {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }

    print "\nFetching general discussion comments for PR #$current_pr...\n";

    # Use gh pr view --json comments to get the list of PR discussion comments
    my $cmd = "gh pr view $current_pr --json comments 2>/dev/null";

    my $json_output = `$cmd`;
    
    if ($? != 0) {
        print "Error: Failed to execute 'gh pr view --json comments'.\n";
        return;
    }

    my $data;
    eval {
        $data = decode_json($json_output);
    };

    if ($@ || !defined $data->{comments} || !ref $data->{comments}) {
        print "Error: Failed to parse general comments JSON.\n";
        return;
    }

    my @comments = @{$data->{comments}};

    if (!@comments) {
        print "No general discussion comments found for PR #$current_pr.\n";
        return;
    }
    
    print "\n### üí¨ General PR Discussion Comments (" . scalar(@comments) . ") ###\n";
    print "------------------------------------------------------\n";

    # Display comments in reverse chronological order (newest first)
    @comments = sort { $b->{createdAt} cmp $a->{createdAt} } @comments;

    for my $c (@comments) {
        my $user = $c->{author}->{login} // 'Unknown User';
        my $date_str = substr($c->{createdAt}, 0, 10);
        my $body = $c->{body} // 'No body content.';
        
        # Display the header and a short preview
        print sprintf("\n[%s] Comment by **%s** on %s\n", 
            $c->{id} || 'N/A', $user, $date_str
        );
        
        # Use a blockquote for the body content
        my @body_lines = split /\n/, $body;
        my $preview_lines = 0;
        
        for my $line (@body_lines) {
            # Skip empty lines that might start the body
            next if $line =~ /^\s*$/ && $preview_lines == 0; 
            
            # Print up to 64 lines of preview
            print "    > $line\n";
            $preview_lines++;
            last if $preview_lines >= 64;
        }

        # Indicate if the comment was truncated
        print "    > ... (truncated) ...\n" if scalar(@body_lines) > $preview_lines;
    }
    print "------------------------------------------------------\n";
}

sub cmd_show_diffs_ignore_whitespace {
    if (!defined $current_pr) {
        print "Error: No PR selected. Use 'pr <PR#>' first.\n";
        return;
    }
    if (!defined $current_file_name) {
        print "Error: No file selected. Use 'sf <file#>' or '+' first.\n";
        return;
    }

    # --- 1. Ensure the PR's head commit is local (Required to avoid 'bad object') ---
    print "Ensuring PR #$current_pr history is available locally...\n";
    
    # Use git fetch with the PR refspec to pull down the required commits without checking out the branch.
    # The refspec format is 'pull/<PR_NUM>/head'.
    my @fetch_cmd = ("git", "fetch", "origin", "pull/$current_pr/head:refs/pr_temp/$current_pr");
    
    print "Executing: @fetch_cmd\n";
    # We use system for git commands that modify the local repo state (like fetch)
    system(@fetch_cmd); 
    
    if ($? != 0) {
        print "\nError: Failed to fetch PR #$current_pr head commits. Cannot proceed with diff.\n";
        return;
    }
    print "Fetch complete.\n";

    # --- 2. Fetch the necessary commit SHAs using gh pr view ---
    print "Fetching base and head commit SHAs...\n";
    
    # We need baseRefOid (the base branch's commit) and headRefOid (the PR branch's commit)
    my $sha_cmd = "gh pr view $current_pr --json baseRefOid,headRefOid 2>/dev/null";
    my $json_output = `$sha_cmd`;

    # ... (Error handling and JSON parsing remains the same) ...
    my $data;
    eval { $data = decode_json($json_output); };
    if ($@ || !defined $data->{baseRefOid} || !defined $data->{headRefOid}) {
        print "Error: Failed to parse commit SHAs from gh CLI output.\n";
        return;
    }
    
    my $base_sha = $data->{baseRefOid};
    my $head_sha = $data->{headRefOid};
    
    print "Diff (ignoring whitespace) for file: **$current_file_name**\n";

    # --- 3. Execute the raw 'git diff' command ---
    my @diff_cmd_parts = (
        "git",
        "diff",
        "--ignore-all-space", # The desired flag
        "$base_sha",          # Base commit SHA
        "$head_sha",          # Head commit SHA
        "--",                 # Separator
        $current_file_name    # File path
    );
    
    system(@diff_cmd_parts);
    
    # --- 4. Cleanup (Optional, but recommended) ---
    # Delete the temporary fetched reference after the diff is done.
    system("git", "update-ref", "-d", "refs/pr_temp/$current_pr");
}
